// @generated by protobuf-ts 2.9.6
// @generated from protobuf file "taskqueue.proto" (package "taskqueue", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message taskqueue.TaskResponse
 */
export interface TaskResponse {
    /**
     * @generated from protobuf field: uint32 task_id = 1;
     */
    taskId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerInfo
 */
export interface WorkerInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: optional uint32 concurrency = 2;
     */
    concurrency?: number;
}
/**
 * @generated from protobuf message taskqueue.Task
 */
export interface Task {
    /**
     * @generated from protobuf field: optional uint32 task_id = 1;
     */
    taskId?: number;
    /**
     * @generated from protobuf field: string command = 2;
     */
    command: string;
    /**
     * @generated from protobuf field: optional string shell = 3;
     */
    shell?: string;
    /**
     * @generated from protobuf field: string container = 4;
     */
    container: string;
    /**
     * @generated from protobuf field: optional string container_options = 5;
     */
    containerOptions?: string;
    /**
     * @generated from protobuf field: optional uint32 step_id = 6;
     */
    stepId?: number;
    /**
     * @generated from protobuf field: repeated string input = 7;
     */
    input: string[];
    /**
     * @generated from protobuf field: repeated string resource = 8;
     */
    resource: string[];
    /**
     * @generated from protobuf field: optional string output = 9;
     */
    output?: string;
    /**
     * @generated from protobuf field: optional uint32 retry = 10;
     */
    retry?: number;
    /**
     * @generated from protobuf field: optional bool is_final = 11;
     */
    isFinal?: boolean;
    /**
     * @generated from protobuf field: optional bool uses_cache = 12;
     */
    usesCache?: boolean;
    /**
     * @generated from protobuf field: optional float download_timeout = 13;
     */
    downloadTimeout?: number;
    /**
     * @generated from protobuf field: optional float running_timeout = 14;
     */
    runningTimeout?: number;
    /**
     * @generated from protobuf field: optional float upload_timeout = 15;
     */
    uploadTimeout?: number;
    /**
     * @generated from protobuf field: string status = 16;
     */
    status: string;
}
/**
 * @generated from protobuf message taskqueue.TaskList
 */
export interface TaskList {
    /**
     * @generated from protobuf field: repeated taskqueue.Task tasks = 1;
     */
    tasks: Task[];
}
/**
 * @generated from protobuf message taskqueue.Worker
 */
export interface Worker {
    /**
     * @generated from protobuf field: uint32 worker_id = 1;
     */
    workerId: number;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 concurrency = 3;
     */
    concurrency: number;
    /**
     * @generated from protobuf field: uint32 prefetch = 4;
     */
    prefetch: number;
    /**
     * @generated from protobuf field: string status = 5;
     */
    status: string;
    /**
     * @generated from protobuf field: string ipv4 = 6;
     */
    ipv4: string;
    /**
     * @generated from protobuf field: string ipv6 = 7;
     */
    ipv6: string;
    /**
     * @generated from protobuf field: string flavor = 8;
     */
    flavor: string;
    /**
     * @generated from protobuf field: string provider = 9;
     */
    provider: string;
    /**
     * @generated from protobuf field: string region = 10;
     */
    region: string;
}
/**
 * @generated from protobuf message taskqueue.WorkersList
 */
export interface WorkersList {
    /**
     * @generated from protobuf field: repeated taskqueue.Worker workers = 1;
     */
    workers: Worker[];
}
/**
 * @generated from protobuf message taskqueue.ListWorkersRequest
 */
export interface ListWorkersRequest {
}
/**
 * @generated from protobuf message taskqueue.TaskListAndOther
 */
export interface TaskListAndOther {
    /**
     * @generated from protobuf field: repeated taskqueue.Task tasks = 1;
     */
    tasks: Task[];
    /**
     * @generated from protobuf field: uint32 concurrency = 2;
     */
    concurrency: number;
}
/**
 * @generated from protobuf message taskqueue.TaskStatusUpdate
 */
export interface TaskStatusUpdate {
    /**
     * @generated from protobuf field: uint32 task_id = 1;
     */
    taskId: number;
    /**
     * @generated from protobuf field: string new_status = 2;
     */
    newStatus: string;
}
/**
 * @generated from protobuf message taskqueue.TaskLog
 */
export interface TaskLog {
    /**
     * @generated from protobuf field: uint32 task_id = 1;
     */
    taskId: number;
    /**
     * @generated from protobuf field: string log_type = 2;
     */
    logType: string; // 'O' for stdout, 'E' for stderr
    /**
     * @generated from protobuf field: string log_text = 3;
     */
    logText: string;
}
/**
 * @generated from protobuf message taskqueue.TaskId
 */
export interface TaskId {
    /**
     * @generated from protobuf field: uint32 task_id = 1;
     */
    taskId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerId
 */
export interface WorkerId {
    /**
     * @generated from protobuf field: uint32 worker_id = 1;
     */
    workerId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerIds
 */
export interface WorkerIds {
    /**
     * @generated from protobuf field: repeated uint32 worker_ids = 1;
     */
    workerIds: number[];
}
/**
 * @generated from protobuf message taskqueue.Ack
 */
export interface Ack {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
}
/**
 * @generated from protobuf message taskqueue.ListTasksRequest
 */
export interface ListTasksRequest {
    /**
     * @generated from protobuf field: optional string status_filter = 1;
     */
    statusFilter?: string;
}
/**
 * @generated from protobuf message taskqueue.WorkerRequest
 */
export interface WorkerRequest {
    /**
     * @generated from protobuf field: uint32 provider_id = 1;
     */
    providerId: number;
    /**
     * @generated from protobuf field: uint32 flavor_id = 2;
     */
    flavorId: number;
    /**
     * @generated from protobuf field: uint32 region_id = 3;
     */
    regionId: number;
    /**
     * @generated from protobuf field: uint32 number = 4;
     */
    number: number;
    /**
     * @generated from protobuf field: uint32 concurrency = 5;
     */
    concurrency: number;
    /**
     * @generated from protobuf field: uint32 prefetch = 6;
     */
    prefetch: number;
    /**
     * @generated from protobuf field: uint32 step_id = 7;
     */
    stepId: number;
}
/**
 * @generated from protobuf message taskqueue.ListFlavorsRequest
 */
export interface ListFlavorsRequest {
    /**
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
    /**
     * @generated from protobuf field: string filter = 2;
     */
    filter: string;
}
/**
 * @generated from protobuf message taskqueue.Flavor
 */
export interface Flavor {
    /**
     * Fields from the "flavor" table
     *
     * @generated from protobuf field: uint32 flavor_id = 1;
     */
    flavorId: number; // PRIMARY KEY
    /**
     * @generated from protobuf field: string flavor_name = 2;
     */
    flavorName: string; // Name of the flavor
    /**
     * @generated from protobuf field: uint32 provider_id = 3;
     */
    providerId: number; // Foreign key to provider table
    /**
     * @generated from protobuf field: string provider = 4;
     */
    provider: string; // Name of the provider (provider_name.config_name)
    /**
     * @generated from protobuf field: int32 cpu = 5;
     */
    cpu: number; // Number of CPU cores
    /**
     * @generated from protobuf field: float mem = 6;
     */
    mem: number; // Memory in GB (or as needed)
    /**
     * @generated from protobuf field: float disk = 7;
     */
    disk: number; // Disk size in GB (or as needed)
    /**
     * @generated from protobuf field: int32 bandwidth = 8;
     */
    bandwidth: number; // Bandwidth (if applicable)
    /**
     * @generated from protobuf field: string gpu = 9;
     */
    gpu: string; // GPU description
    /**
     * @generated from protobuf field: int32 gpumem = 10;
     */
    gpumem: number; // GPU memory (in GB, for example)
    /**
     * @generated from protobuf field: bool has_gpu = 11;
     */
    hasGpu: boolean; // Whether a GPU is present
    /**
     * @generated from protobuf field: bool has_quick_disks = 12;
     */
    hasQuickDisks: boolean; // Whether quick disks are supported
    /**
     * Fields from the "flavor_region" table
     *
     * @generated from protobuf field: uint32 region_id = 13;
     */
    regionId: number; // Foreign key to region table
    /**
     * @generated from protobuf field: string region = 14;
     */
    region: string; // (Optional) Region name
    /**
     * @generated from protobuf field: float eviction = 15;
     */
    eviction: number; // Eviction rate value
    /**
     * @generated from protobuf field: float cost = 16;
     */
    cost: number; // Cost value
}
/**
 * @generated from protobuf message taskqueue.FlavorsList
 */
export interface FlavorsList {
    /**
     * @generated from protobuf field: repeated taskqueue.Flavor flavors = 1;
     */
    flavors: Flavor[];
}
/**
 * @generated from protobuf message taskqueue.RcloneConfig
 */
export interface RcloneConfig {
    /**
     * @generated from protobuf field: string config = 1;
     */
    config: string;
}
/**
 * @generated from protobuf message taskqueue.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
}
/**
 * @generated from protobuf message taskqueue.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: string token = 1;
     */
    token: string;
}
/**
 * @generated from protobuf message taskqueue.CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2;
     */
    password: string;
    /**
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * @generated from protobuf field: bool is_admin = 4;
     */
    isAdmin: boolean;
}
/**
 * @generated from protobuf message taskqueue.UserId
 */
export interface UserId {
    /**
     * @generated from protobuf field: uint32 user_id = 1;
     */
    userId: number;
}
/**
 * @generated from protobuf message taskqueue.User
 */
export interface User {
    /**
     * @generated from protobuf field: uint32 user_id = 1;
     */
    userId: number;
    /**
     * @generated from protobuf field: optional string username = 2;
     */
    username?: string;
    /**
     * @generated from protobuf field: optional string email = 3;
     */
    email?: string;
    /**
     * @generated from protobuf field: optional bool is_admin = 4;
     */
    isAdmin?: boolean;
}
/**
 * @generated from protobuf message taskqueue.UsersList
 */
export interface UsersList {
    /**
     * @generated from protobuf field: repeated taskqueue.User users = 1;
     */
    users: User[];
}
/**
 * @generated from protobuf message taskqueue.ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * @generated from protobuf field: string username = 1;
     */
    username: string;
    /**
     * @generated from protobuf field: string old_password = 2;
     */
    oldPassword: string;
    /**
     * @generated from protobuf field: string new_password = 3;
     */
    newPassword: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class TaskResponse$Type extends MessageType<TaskResponse> {
    constructor() {
        super("taskqueue.TaskResponse", [
            { no: 1, name: "task_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskResponse>): TaskResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskResponse): TaskResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 task_id */ 1:
                    message.taskId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskResponse
 */
export const TaskResponse = new TaskResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerInfo$Type extends MessageType<WorkerInfo> {
    constructor() {
        super("taskqueue.WorkerInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "concurrency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerInfo>): WorkerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WorkerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerInfo): WorkerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional uint32 concurrency */ 2:
                    message.concurrency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional uint32 concurrency = 2; */
        if (message.concurrency !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.concurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerInfo
 */
export const WorkerInfo = new WorkerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("taskqueue.Task", [
            { no: 1, name: "task_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shell", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "container", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "container_options", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "step_id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "input", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "resource", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "output", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "retry", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "is_final", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "uses_cache", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "download_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "running_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "upload_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = "";
        message.container = "";
        message.input = [];
        message.resource = [];
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 task_id */ 1:
                    message.taskId = reader.uint32();
                    break;
                case /* string command */ 2:
                    message.command = reader.string();
                    break;
                case /* optional string shell */ 3:
                    message.shell = reader.string();
                    break;
                case /* string container */ 4:
                    message.container = reader.string();
                    break;
                case /* optional string container_options */ 5:
                    message.containerOptions = reader.string();
                    break;
                case /* optional uint32 step_id */ 6:
                    message.stepId = reader.uint32();
                    break;
                case /* repeated string input */ 7:
                    message.input.push(reader.string());
                    break;
                case /* repeated string resource */ 8:
                    message.resource.push(reader.string());
                    break;
                case /* optional string output */ 9:
                    message.output = reader.string();
                    break;
                case /* optional uint32 retry */ 10:
                    message.retry = reader.uint32();
                    break;
                case /* optional bool is_final */ 11:
                    message.isFinal = reader.bool();
                    break;
                case /* optional bool uses_cache */ 12:
                    message.usesCache = reader.bool();
                    break;
                case /* optional float download_timeout */ 13:
                    message.downloadTimeout = reader.float();
                    break;
                case /* optional float running_timeout */ 14:
                    message.runningTimeout = reader.float();
                    break;
                case /* optional float upload_timeout */ 15:
                    message.uploadTimeout = reader.float();
                    break;
                case /* string status */ 16:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 task_id = 1; */
        if (message.taskId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.taskId);
        /* string command = 2; */
        if (message.command !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.command);
        /* optional string shell = 3; */
        if (message.shell !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.shell);
        /* string container = 4; */
        if (message.container !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.container);
        /* optional string container_options = 5; */
        if (message.containerOptions !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.containerOptions);
        /* optional uint32 step_id = 6; */
        if (message.stepId !== undefined)
            writer.tag(6, WireType.Varint).uint32(message.stepId);
        /* repeated string input = 7; */
        for (let i = 0; i < message.input.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.input[i]);
        /* repeated string resource = 8; */
        for (let i = 0; i < message.resource.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.resource[i]);
        /* optional string output = 9; */
        if (message.output !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.output);
        /* optional uint32 retry = 10; */
        if (message.retry !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.retry);
        /* optional bool is_final = 11; */
        if (message.isFinal !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isFinal);
        /* optional bool uses_cache = 12; */
        if (message.usesCache !== undefined)
            writer.tag(12, WireType.Varint).bool(message.usesCache);
        /* optional float download_timeout = 13; */
        if (message.downloadTimeout !== undefined)
            writer.tag(13, WireType.Bit32).float(message.downloadTimeout);
        /* optional float running_timeout = 14; */
        if (message.runningTimeout !== undefined)
            writer.tag(14, WireType.Bit32).float(message.runningTimeout);
        /* optional float upload_timeout = 15; */
        if (message.uploadTimeout !== undefined)
            writer.tag(15, WireType.Bit32).float(message.uploadTimeout);
        /* string status = 16; */
        if (message.status !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskList$Type extends MessageType<TaskList> {
    constructor() {
        super("taskqueue.TaskList", [
            { no: 1, name: "tasks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Task }
        ]);
    }
    create(value?: PartialMessage<TaskList>): TaskList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        if (value !== undefined)
            reflectionMergePartial<TaskList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskList): TaskList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskList
 */
export const TaskList = new TaskList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Worker$Type extends MessageType<Worker> {
    constructor() {
        super("taskqueue.Worker", [
            { no: 1, name: "worker_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "prefetch", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "ipv4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ipv6", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "flavor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Worker>): Worker {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        message.name = "";
        message.concurrency = 0;
        message.prefetch = 0;
        message.status = "";
        message.ipv4 = "";
        message.ipv6 = "";
        message.flavor = "";
        message.provider = "";
        message.region = "";
        if (value !== undefined)
            reflectionMergePartial<Worker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Worker): Worker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 worker_id */ 1:
                    message.workerId = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* uint32 concurrency */ 3:
                    message.concurrency = reader.uint32();
                    break;
                case /* uint32 prefetch */ 4:
                    message.prefetch = reader.uint32();
                    break;
                case /* string status */ 5:
                    message.status = reader.string();
                    break;
                case /* string ipv4 */ 6:
                    message.ipv4 = reader.string();
                    break;
                case /* string ipv6 */ 7:
                    message.ipv6 = reader.string();
                    break;
                case /* string flavor */ 8:
                    message.flavor = reader.string();
                    break;
                case /* string provider */ 9:
                    message.provider = reader.string();
                    break;
                case /* string region */ 10:
                    message.region = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Worker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.workerId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* uint32 concurrency = 3; */
        if (message.concurrency !== 0)
            writer.tag(3, WireType.Varint).uint32(message.concurrency);
        /* uint32 prefetch = 4; */
        if (message.prefetch !== 0)
            writer.tag(4, WireType.Varint).uint32(message.prefetch);
        /* string status = 5; */
        if (message.status !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.status);
        /* string ipv4 = 6; */
        if (message.ipv4 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.ipv4);
        /* string ipv6 = 7; */
        if (message.ipv6 !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ipv6);
        /* string flavor = 8; */
        if (message.flavor !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.flavor);
        /* string provider = 9; */
        if (message.provider !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.provider);
        /* string region = 10; */
        if (message.region !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.region);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Worker
 */
export const Worker = new Worker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkersList$Type extends MessageType<WorkersList> {
    constructor() {
        super("taskqueue.WorkersList", [
            { no: 1, name: "workers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Worker }
        ]);
    }
    create(value?: PartialMessage<WorkersList>): WorkersList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workers = [];
        if (value !== undefined)
            reflectionMergePartial<WorkersList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkersList): WorkersList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Worker workers */ 1:
                    message.workers.push(Worker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkersList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Worker workers = 1; */
        for (let i = 0; i < message.workers.length; i++)
            Worker.internalBinaryWrite(message.workers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkersList
 */
export const WorkersList = new WorkersList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWorkersRequest$Type extends MessageType<ListWorkersRequest> {
    constructor() {
        super("taskqueue.ListWorkersRequest", []);
    }
    create(value?: PartialMessage<ListWorkersRequest>): ListWorkersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListWorkersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWorkersRequest): ListWorkersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWorkersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ListWorkersRequest
 */
export const ListWorkersRequest = new ListWorkersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskListAndOther$Type extends MessageType<TaskListAndOther> {
    constructor() {
        super("taskqueue.TaskListAndOther", [
            { no: 1, name: "tasks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Task },
            { no: 2, name: "concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskListAndOther>): TaskListAndOther {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        message.concurrency = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskListAndOther>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskListAndOther): TaskListAndOther {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 concurrency */ 2:
                    message.concurrency = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskListAndOther, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 concurrency = 2; */
        if (message.concurrency !== 0)
            writer.tag(2, WireType.Varint).uint32(message.concurrency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskListAndOther
 */
export const TaskListAndOther = new TaskListAndOther$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskStatusUpdate$Type extends MessageType<TaskStatusUpdate> {
    constructor() {
        super("taskqueue.TaskStatusUpdate", [
            { no: 1, name: "task_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "new_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskStatusUpdate>): TaskStatusUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.newStatus = "";
        if (value !== undefined)
            reflectionMergePartial<TaskStatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskStatusUpdate): TaskStatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 task_id */ 1:
                    message.taskId = reader.uint32();
                    break;
                case /* string new_status */ 2:
                    message.newStatus = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskStatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.taskId);
        /* string new_status = 2; */
        if (message.newStatus !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskStatusUpdate
 */
export const TaskStatusUpdate = new TaskStatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskLog$Type extends MessageType<TaskLog> {
    constructor() {
        super("taskqueue.TaskLog", [
            { no: 1, name: "task_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "log_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "log_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskLog>): TaskLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.logType = "";
        message.logText = "";
        if (value !== undefined)
            reflectionMergePartial<TaskLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskLog): TaskLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 task_id */ 1:
                    message.taskId = reader.uint32();
                    break;
                case /* string log_type */ 2:
                    message.logType = reader.string();
                    break;
                case /* string log_text */ 3:
                    message.logText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.taskId);
        /* string log_type = 2; */
        if (message.logType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.logType);
        /* string log_text = 3; */
        if (message.logText !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.logText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskLog
 */
export const TaskLog = new TaskLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskId$Type extends MessageType<TaskId> {
    constructor() {
        super("taskqueue.TaskId", [
            { no: 1, name: "task_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskId>): TaskId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskId): TaskId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 task_id */ 1:
                    message.taskId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskId
 */
export const TaskId = new TaskId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerId$Type extends MessageType<WorkerId> {
    constructor() {
        super("taskqueue.WorkerId", [
            { no: 1, name: "worker_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerId>): WorkerId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerId): WorkerId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 worker_id */ 1:
                    message.workerId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.workerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerId
 */
export const WorkerId = new WorkerId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerIds$Type extends MessageType<WorkerIds> {
    constructor() {
        super("taskqueue.WorkerIds", [
            { no: 1, name: "worker_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerIds>): WorkerIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerIds = [];
        if (value !== undefined)
            reflectionMergePartial<WorkerIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerIds): WorkerIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 worker_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.workerIds.push(reader.uint32());
                    else
                        message.workerIds.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 worker_ids = 1; */
        if (message.workerIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.workerIds.length; i++)
                writer.uint32(message.workerIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerIds
 */
export const WorkerIds = new WorkerIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ack$Type extends MessageType<Ack> {
    constructor() {
        super("taskqueue.Ack", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Ack>): Ack {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<Ack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ack): Ack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Ack
 */
export const Ack = new Ack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTasksRequest$Type extends MessageType<ListTasksRequest> {
    constructor() {
        super("taskqueue.ListTasksRequest", [
            { no: 1, name: "status_filter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListTasksRequest>): ListTasksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListTasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTasksRequest): ListTasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string status_filter */ 1:
                    message.statusFilter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string status_filter = 1; */
        if (message.statusFilter !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.statusFilter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ListTasksRequest
 */
export const ListTasksRequest = new ListTasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerRequest$Type extends MessageType<WorkerRequest> {
    constructor() {
        super("taskqueue.WorkerRequest", [
            { no: 1, name: "provider_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "flavor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "region_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "concurrency", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "prefetch", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "step_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerRequest>): WorkerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerId = 0;
        message.flavorId = 0;
        message.regionId = 0;
        message.number = 0;
        message.concurrency = 0;
        message.prefetch = 0;
        message.stepId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerRequest): WorkerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 provider_id */ 1:
                    message.providerId = reader.uint32();
                    break;
                case /* uint32 flavor_id */ 2:
                    message.flavorId = reader.uint32();
                    break;
                case /* uint32 region_id */ 3:
                    message.regionId = reader.uint32();
                    break;
                case /* uint32 number */ 4:
                    message.number = reader.uint32();
                    break;
                case /* uint32 concurrency */ 5:
                    message.concurrency = reader.uint32();
                    break;
                case /* uint32 prefetch */ 6:
                    message.prefetch = reader.uint32();
                    break;
                case /* uint32 step_id */ 7:
                    message.stepId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 provider_id = 1; */
        if (message.providerId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.providerId);
        /* uint32 flavor_id = 2; */
        if (message.flavorId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.flavorId);
        /* uint32 region_id = 3; */
        if (message.regionId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.regionId);
        /* uint32 number = 4; */
        if (message.number !== 0)
            writer.tag(4, WireType.Varint).uint32(message.number);
        /* uint32 concurrency = 5; */
        if (message.concurrency !== 0)
            writer.tag(5, WireType.Varint).uint32(message.concurrency);
        /* uint32 prefetch = 6; */
        if (message.prefetch !== 0)
            writer.tag(6, WireType.Varint).uint32(message.prefetch);
        /* uint32 step_id = 7; */
        if (message.stepId !== 0)
            writer.tag(7, WireType.Varint).uint32(message.stepId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerRequest
 */
export const WorkerRequest = new WorkerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFlavorsRequest$Type extends MessageType<ListFlavorsRequest> {
    constructor() {
        super("taskqueue.ListFlavorsRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListFlavorsRequest>): ListFlavorsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.filter = "";
        if (value !== undefined)
            reflectionMergePartial<ListFlavorsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFlavorsRequest): ListFlavorsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* string filter */ 2:
                    message.filter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFlavorsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* string filter = 2; */
        if (message.filter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ListFlavorsRequest
 */
export const ListFlavorsRequest = new ListFlavorsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Flavor$Type extends MessageType<Flavor> {
    constructor() {
        super("taskqueue.Flavor", [
            { no: 1, name: "flavor_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "flavor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "provider_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cpu", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "mem", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "disk", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "bandwidth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "gpu", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "gpumem", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "has_gpu", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "has_quick_disks", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "region_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 14, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "eviction", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "cost", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Flavor>): Flavor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flavorId = 0;
        message.flavorName = "";
        message.providerId = 0;
        message.provider = "";
        message.cpu = 0;
        message.mem = 0;
        message.disk = 0;
        message.bandwidth = 0;
        message.gpu = "";
        message.gpumem = 0;
        message.hasGpu = false;
        message.hasQuickDisks = false;
        message.regionId = 0;
        message.region = "";
        message.eviction = 0;
        message.cost = 0;
        if (value !== undefined)
            reflectionMergePartial<Flavor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Flavor): Flavor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 flavor_id */ 1:
                    message.flavorId = reader.uint32();
                    break;
                case /* string flavor_name */ 2:
                    message.flavorName = reader.string();
                    break;
                case /* uint32 provider_id */ 3:
                    message.providerId = reader.uint32();
                    break;
                case /* string provider */ 4:
                    message.provider = reader.string();
                    break;
                case /* int32 cpu */ 5:
                    message.cpu = reader.int32();
                    break;
                case /* float mem */ 6:
                    message.mem = reader.float();
                    break;
                case /* float disk */ 7:
                    message.disk = reader.float();
                    break;
                case /* int32 bandwidth */ 8:
                    message.bandwidth = reader.int32();
                    break;
                case /* string gpu */ 9:
                    message.gpu = reader.string();
                    break;
                case /* int32 gpumem */ 10:
                    message.gpumem = reader.int32();
                    break;
                case /* bool has_gpu */ 11:
                    message.hasGpu = reader.bool();
                    break;
                case /* bool has_quick_disks */ 12:
                    message.hasQuickDisks = reader.bool();
                    break;
                case /* uint32 region_id */ 13:
                    message.regionId = reader.uint32();
                    break;
                case /* string region */ 14:
                    message.region = reader.string();
                    break;
                case /* float eviction */ 15:
                    message.eviction = reader.float();
                    break;
                case /* float cost */ 16:
                    message.cost = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Flavor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 flavor_id = 1; */
        if (message.flavorId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.flavorId);
        /* string flavor_name = 2; */
        if (message.flavorName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.flavorName);
        /* uint32 provider_id = 3; */
        if (message.providerId !== 0)
            writer.tag(3, WireType.Varint).uint32(message.providerId);
        /* string provider = 4; */
        if (message.provider !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.provider);
        /* int32 cpu = 5; */
        if (message.cpu !== 0)
            writer.tag(5, WireType.Varint).int32(message.cpu);
        /* float mem = 6; */
        if (message.mem !== 0)
            writer.tag(6, WireType.Bit32).float(message.mem);
        /* float disk = 7; */
        if (message.disk !== 0)
            writer.tag(7, WireType.Bit32).float(message.disk);
        /* int32 bandwidth = 8; */
        if (message.bandwidth !== 0)
            writer.tag(8, WireType.Varint).int32(message.bandwidth);
        /* string gpu = 9; */
        if (message.gpu !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.gpu);
        /* int32 gpumem = 10; */
        if (message.gpumem !== 0)
            writer.tag(10, WireType.Varint).int32(message.gpumem);
        /* bool has_gpu = 11; */
        if (message.hasGpu !== false)
            writer.tag(11, WireType.Varint).bool(message.hasGpu);
        /* bool has_quick_disks = 12; */
        if (message.hasQuickDisks !== false)
            writer.tag(12, WireType.Varint).bool(message.hasQuickDisks);
        /* uint32 region_id = 13; */
        if (message.regionId !== 0)
            writer.tag(13, WireType.Varint).uint32(message.regionId);
        /* string region = 14; */
        if (message.region !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.region);
        /* float eviction = 15; */
        if (message.eviction !== 0)
            writer.tag(15, WireType.Bit32).float(message.eviction);
        /* float cost = 16; */
        if (message.cost !== 0)
            writer.tag(16, WireType.Bit32).float(message.cost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Flavor
 */
export const Flavor = new Flavor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlavorsList$Type extends MessageType<FlavorsList> {
    constructor() {
        super("taskqueue.FlavorsList", [
            { no: 1, name: "flavors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Flavor }
        ]);
    }
    create(value?: PartialMessage<FlavorsList>): FlavorsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flavors = [];
        if (value !== undefined)
            reflectionMergePartial<FlavorsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlavorsList): FlavorsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Flavor flavors */ 1:
                    message.flavors.push(Flavor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlavorsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Flavor flavors = 1; */
        for (let i = 0; i < message.flavors.length; i++)
            Flavor.internalBinaryWrite(message.flavors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.FlavorsList
 */
export const FlavorsList = new FlavorsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RcloneConfig$Type extends MessageType<RcloneConfig> {
    constructor() {
        super("taskqueue.RcloneConfig", [
            { no: 1, name: "config", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RcloneConfig>): RcloneConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.config = "";
        if (value !== undefined)
            reflectionMergePartial<RcloneConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RcloneConfig): RcloneConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string config */ 1:
                    message.config = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RcloneConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string config = 1; */
        if (message.config !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.config);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RcloneConfig
 */
export const RcloneConfig = new RcloneConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("taskqueue.LoginRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("taskqueue.LoginResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserRequest$Type extends MessageType<CreateUserRequest> {
    constructor() {
        super("taskqueue.CreateUserRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreateUserRequest>): CreateUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        message.email = "";
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<CreateUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserRequest): CreateUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* bool is_admin */ 4:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* bool is_admin = 4; */
        if (message.isAdmin !== false)
            writer.tag(4, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.CreateUserRequest
 */
export const CreateUserRequest = new CreateUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserId$Type extends MessageType<UserId> {
    constructor() {
        super("taskqueue.UserId", [
            { no: 1, name: "user_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UserId>): UserId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0;
        if (value !== undefined)
            reflectionMergePartial<UserId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserId): UserId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 user_id */ 1:
                    message.userId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 user_id = 1; */
        if (message.userId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.UserId
 */
export const UserId = new UserId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("taskqueue.User", [
            { no: 1, name: "user_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_admin", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0;
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 user_id */ 1:
                    message.userId = reader.uint32();
                    break;
                case /* optional string username */ 2:
                    message.username = reader.string();
                    break;
                case /* optional string email */ 3:
                    message.email = reader.string();
                    break;
                case /* optional bool is_admin */ 4:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 user_id = 1; */
        if (message.userId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.userId);
        /* optional string username = 2; */
        if (message.username !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* optional string email = 3; */
        if (message.email !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* optional bool is_admin = 4; */
        if (message.isAdmin !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UsersList$Type extends MessageType<UsersList> {
    constructor() {
        super("taskqueue.UsersList", [
            { no: 1, name: "users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => User }
        ]);
    }
    create(value?: PartialMessage<UsersList>): UsersList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial<UsersList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsersList): UsersList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.User users */ 1:
                    message.users.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UsersList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.User users = 1; */
        for (let i = 0; i < message.users.length; i++)
            User.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.UsersList
 */
export const UsersList = new UsersList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordRequest$Type extends MessageType<ChangePasswordRequest> {
    constructor() {
        super("taskqueue.ChangePasswordRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "old_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordRequest>): ChangePasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.oldPassword = "";
        message.newPassword = "";
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordRequest): ChangePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string old_password */ 2:
                    message.oldPassword = reader.string();
                    break;
                case /* string new_password */ 3:
                    message.newPassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string old_password = 2; */
        if (message.oldPassword !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oldPassword);
        /* string new_password = 3; */
        if (message.newPassword !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ChangePasswordRequest
 */
export const ChangePasswordRequest = new ChangePasswordRequest$Type();
/**
 * @generated ServiceType for protobuf service taskqueue.TaskQueue
 */
export const TaskQueue = new ServiceType("taskqueue.TaskQueue", [
    { name: "SubmitTask", options: {}, I: Task, O: TaskResponse },
    { name: "RegisterWorker", options: {}, I: WorkerInfo, O: WorkerId },
    { name: "PingAndTakeNewTasks", options: {}, I: WorkerId, O: TaskListAndOther },
    { name: "UpdateTaskStatus", options: {}, I: TaskStatusUpdate, O: Ack },
    { name: "SendTaskLogs", clientStreaming: true, options: {}, I: TaskLog, O: Ack },
    { name: "StreamTaskLogs", serverStreaming: true, options: {}, I: TaskId, O: TaskLog },
    { name: "ListTasks", options: {}, I: ListTasksRequest, O: TaskList },
    { name: "ListWorkers", options: {}, I: ListWorkersRequest, O: WorkersList },
    { name: "CreateWorker", options: {}, I: WorkerRequest, O: WorkerIds },
    { name: "DeleteWorker", options: {}, I: WorkerId, O: Ack },
    { name: "ListFlavors", options: {}, I: ListFlavorsRequest, O: FlavorsList },
    { name: "GetRcloneConfig", options: {}, I: Empty, O: RcloneConfig },
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "CreateUser", options: {}, I: CreateUserRequest, O: Ack },
    { name: "ListUsers", options: {}, I: Empty, O: UsersList },
    { name: "DeleteUser", options: {}, I: UserId, O: Ack },
    { name: "UpdateUser", options: {}, I: User, O: Ack },
    { name: "ChangePassword", options: {}, I: ChangePasswordRequest, O: Ack }
]);
