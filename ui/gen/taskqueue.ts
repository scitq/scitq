// @generated by protobuf-ts 2.11.1 with parameter long_type_string
// @generated from protobuf file "taskqueue.proto" (package "taskqueue", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message taskqueue.TaskResponse
 */
export interface TaskResponse {
    /**
     * @generated from protobuf field: int32 task_id = 1
     */
    taskId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerInfo
 */
export interface WorkerInfo {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: optional int32 concurrency = 2
     */
    concurrency?: number;
    /**
     * @generated from protobuf field: optional bool is_permanent = 3
     */
    isPermanent?: boolean;
    /**
     * @generated from protobuf field: optional string provider = 4
     */
    provider?: string;
    /**
     * @generated from protobuf field: optional string region = 5
     */
    region?: string;
}
/**
 * @generated from protobuf message taskqueue.TaskRequest
 */
export interface TaskRequest {
    /**
     * @generated from protobuf field: string command = 1
     */
    command: string;
    /**
     * @generated from protobuf field: optional string shell = 2
     */
    shell?: string;
    /**
     * @generated from protobuf field: string container = 3
     */
    container: string;
    /**
     * @generated from protobuf field: optional string container_options = 4
     */
    containerOptions?: string;
    /**
     * @generated from protobuf field: optional int32 step_id = 5
     */
    stepId?: number;
    /**
     * @generated from protobuf field: repeated string input = 6
     */
    input: string[];
    /**
     * @generated from protobuf field: repeated string resource = 7
     */
    resource: string[];
    /**
     * @generated from protobuf field: optional string output = 8
     */
    output?: string;
    /**
     * @generated from protobuf field: optional int32 retry = 9
     */
    retry?: number;
    /**
     * @generated from protobuf field: optional bool is_final = 10
     */
    isFinal?: boolean;
    /**
     * @generated from protobuf field: optional bool uses_cache = 11
     */
    usesCache?: boolean;
    /**
     * @generated from protobuf field: optional float download_timeout = 12
     */
    downloadTimeout?: number;
    /**
     * @generated from protobuf field: optional float running_timeout = 13
     */
    runningTimeout?: number;
    /**
     * @generated from protobuf field: optional float upload_timeout = 14
     */
    uploadTimeout?: number;
    /**
     * @generated from protobuf field: string status = 15
     */
    status: string;
    /**
     * @generated from protobuf field: repeated int32 dependency = 16
     */
    dependency: number[]; // IDs of tasks that this task depends on
    /**
     * @generated from protobuf field: optional string task_name = 17
     */
    taskName?: string;
}
/**
 * @generated from protobuf message taskqueue.Task
 */
export interface Task {
    /**
     * @generated from protobuf field: int32 task_id = 1
     */
    taskId: number;
    /**
     * @generated from protobuf field: string command = 2
     */
    command: string;
    /**
     * @generated from protobuf field: optional string shell = 3
     */
    shell?: string;
    /**
     * @generated from protobuf field: string container = 4
     */
    container: string;
    /**
     * @generated from protobuf field: optional string container_options = 5
     */
    containerOptions?: string;
    /**
     * @generated from protobuf field: optional int32 step_id = 6
     */
    stepId?: number;
    /**
     * @generated from protobuf field: repeated string input = 7
     */
    input: string[];
    /**
     * @generated from protobuf field: repeated string resource = 8
     */
    resource: string[];
    /**
     * @generated from protobuf field: optional string output = 9
     */
    output?: string;
    /**
     * @generated from protobuf field: optional int32 retry = 10
     */
    retry?: number;
    /**
     * @generated from protobuf field: optional bool is_final = 11
     */
    isFinal?: boolean;
    /**
     * @generated from protobuf field: optional bool uses_cache = 12
     */
    usesCache?: boolean;
    /**
     * @generated from protobuf field: optional float download_timeout = 13
     */
    downloadTimeout?: number;
    /**
     * @generated from protobuf field: optional float running_timeout = 14
     */
    runningTimeout?: number;
    /**
     * @generated from protobuf field: optional float upload_timeout = 15
     */
    uploadTimeout?: number;
    /**
     * @generated from protobuf field: string status = 16
     */
    status: string;
    /**
     * @generated from protobuf field: optional int32 worker_id = 17
     */
    workerId?: number;
    /**
     * @generated from protobuf field: optional int32 workflow_id = 18
     */
    workflowId?: number;
    /**
     * @generated from protobuf field: optional string task_name = 19
     */
    taskName?: string;
    /**
     * @generated from protobuf field: int32 retry_count = 20
     */
    retryCount: number;
    /**
     * @generated from protobuf field: bool hidden = 21
     */
    hidden: boolean;
    /**
     * @generated from protobuf field: optional int32 previous_task_id = 22
     */
    previousTaskId?: number;
    /**
     * @generated from protobuf field: optional double weight = 23
     */
    weight?: number; // Fraction of the assigned worker's concurrency consumed by this task (default 1.0)
    /**
     * @generated from protobuf field: optional int64 run_start_time = 24
     */
    runStartTime?: string; // epoch timestamp of the first task start time
}
/**
 * @generated from protobuf message taskqueue.TaskList
 */
export interface TaskList {
    /**
     * @generated from protobuf field: repeated taskqueue.Task tasks = 1
     */
    tasks: Task[];
}
/**
 * @generated from protobuf message taskqueue.RetryTaskRequest
 */
export interface RetryTaskRequest {
    /**
     * @generated from protobuf field: int32 task_id = 1
     */
    taskId: number;
    /**
     * @generated from protobuf field: optional int32 retry = 2
     */
    retry?: number;
}
/**
 * @generated from protobuf message taskqueue.Worker
 */
export interface Worker {
    /**
     * @generated from protobuf field: int32 worker_id = 1
     */
    workerId: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: int32 concurrency = 3
     */
    concurrency: number;
    /**
     * @generated from protobuf field: int32 prefetch = 4
     */
    prefetch: number;
    /**
     * @generated from protobuf field: string status = 5
     */
    status: string;
    /**
     * @generated from protobuf field: string ipv4 = 6
     */
    ipv4: string;
    /**
     * @generated from protobuf field: string ipv6 = 7
     */
    ipv6: string;
    /**
     * @generated from protobuf field: string flavor = 8
     */
    flavor: string;
    /**
     * @generated from protobuf field: string provider = 9
     */
    provider: string;
    /**
     * @generated from protobuf field: string region = 10
     */
    region: string;
    /**
     * @generated from protobuf field: optional int32 step_id = 11
     */
    stepId?: number;
    /**
     * @generated from protobuf field: optional string step_name = 12
     */
    stepName?: string;
    /**
     * @generated from protobuf field: bool is_permanent = 13
     */
    isPermanent: boolean;
    /**
     * @generated from protobuf field: string recyclable_scope = 14
     */
    recyclableScope: string;
    /**
     * @generated from protobuf field: optional int32 workflow_id = 15
     */
    workflowId?: number;
    /**
     * @generated from protobuf field: optional string workflow_name = 16
     */
    workflowName?: string;
}
/**
 * @generated from protobuf message taskqueue.WorkersList
 */
export interface WorkersList {
    /**
     * @generated from protobuf field: repeated taskqueue.Worker workers = 1
     */
    workers: Worker[];
}
/**
 * @generated from protobuf message taskqueue.ListWorkersRequest
 */
export interface ListWorkersRequest {
    /**
     * @generated from protobuf field: optional int32 workflow_id = 1
     */
    workflowId?: number;
}
/**
 * @generated from protobuf message taskqueue.TaskUpdate
 */
export interface TaskUpdate {
    /**
     * @generated from protobuf field: double weight = 1
     */
    weight: number;
}
/**
 * @generated from protobuf message taskqueue.TaskUpdateList
 */
export interface TaskUpdateList {
    /**
     * @generated from protobuf field: map<int32, taskqueue.TaskUpdate> updates = 1
     */
    updates: {
        [key: number]: TaskUpdate;
    }; // optional â€” can be empty
}
/**
 * @generated from protobuf message taskqueue.TaskListAndOther
 */
export interface TaskListAndOther {
    /**
     * @generated from protobuf field: repeated taskqueue.Task tasks = 1
     */
    tasks: Task[];
    /**
     * @generated from protobuf field: int32 concurrency = 2
     */
    concurrency: number;
    /**
     * @generated from protobuf field: taskqueue.TaskUpdateList updates = 3
     */
    updates?: TaskUpdateList;
    /**
     * @generated from protobuf field: repeated int32 active_tasks = 4
     */
    activeTasks: number[];
}
/**
 * @generated from protobuf message taskqueue.TaskStatusUpdate
 */
export interface TaskStatusUpdate {
    /**
     * @generated from protobuf field: int32 task_id = 1
     */
    taskId: number;
    /**
     * @generated from protobuf field: string new_status = 2
     */
    newStatus: string;
    /**
     * @generated from protobuf field: optional int32 duration = 3
     */
    duration?: number; // in seconds
    /**
     * @generated from protobuf field: optional bool free_retry = 4
     */
    freeRetry?: boolean; // if new_status is F and this is true, then retry is increased by 1 before setting status to F
}
/**
 * @generated from protobuf message taskqueue.TaskLog
 */
export interface TaskLog {
    /**
     * @generated from protobuf field: int32 task_id = 1
     */
    taskId: number;
    /**
     * @generated from protobuf field: string log_type = 2
     */
    logType: string; // 'O' for stdout, 'E' for stderr
    /**
     * @generated from protobuf field: string log_text = 3
     */
    logText: string;
}
/**
 * @generated from protobuf message taskqueue.GetLogsRequest
 */
export interface GetLogsRequest {
    /**
     * @generated from protobuf field: repeated int32 taskIds = 1
     */
    taskIds: number[];
    /**
     * @generated from protobuf field: int32 chunkSize = 2
     */
    chunkSize: number;
    /**
     * @generated from protobuf field: optional int32 skipFromEnd = 3
     */
    skipFromEnd?: number;
    /**
     * @generated from protobuf field: optional string log_type = 4
     */
    logType?: string;
}
/**
 * @generated from protobuf message taskqueue.LogChunk
 */
export interface LogChunk {
    /**
     * @generated from protobuf field: int32 taskId = 1
     */
    taskId: number;
    /**
     * @generated from protobuf field: repeated string stdout = 2
     */
    stdout: string[];
    /**
     * @generated from protobuf field: repeated string stderr = 3
     */
    stderr: string[];
}
/**
 * @generated from protobuf message taskqueue.LogChunkList
 */
export interface LogChunkList {
    /**
     * @generated from protobuf field: repeated taskqueue.LogChunk logs = 1
     */
    logs: LogChunk[];
}
/**
 * @generated from protobuf message taskqueue.TaskIds
 */
export interface TaskIds {
    /**
     * @generated from protobuf field: repeated int32 task_ids = 1
     */
    taskIds: number[];
}
/**
 * @generated from protobuf message taskqueue.TaskId
 */
export interface TaskId {
    /**
     * @generated from protobuf field: int32 task_id = 1
     */
    taskId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerId
 */
export interface WorkerId {
    /**
     * @generated from protobuf field: int32 worker_id = 1
     */
    workerId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerDeletion
 */
export interface WorkerDeletion {
    /**
     * @generated from protobuf field: int32 worker_id = 1
     */
    workerId: number;
    /**
     * @generated from protobuf field: optional bool undeployed = 2
     */
    undeployed?: boolean; // if true, the worker is already undeployed so deletion can proceed
}
/**
 * @generated from protobuf message taskqueue.WorkerStatusRequest
 */
export interface WorkerStatusRequest {
    /**
     * @generated from protobuf field: repeated int32 worker_ids = 1
     */
    workerIds: number[];
}
/**
 * @generated from protobuf message taskqueue.WorkerStatus
 */
export interface WorkerStatus {
    /**
     * @generated from protobuf field: int32 worker_id = 1
     */
    workerId: number;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
}
/**
 * @generated from protobuf message taskqueue.WorkerStatusResponse
 */
export interface WorkerStatusResponse {
    /**
     * @generated from protobuf field: repeated taskqueue.WorkerStatus statuses = 1
     */
    statuses: WorkerStatus[];
}
/**
 * @generated from protobuf message taskqueue.WorkerDetails
 */
export interface WorkerDetails {
    /**
     * @generated from protobuf field: int32 worker_id = 1
     */
    workerId: number;
    /**
     * @generated from protobuf field: string worker_name = 2
     */
    workerName: string;
    /**
     * @generated from protobuf field: int32 job_id = 3
     */
    jobId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerIds
 */
export interface WorkerIds {
    /**
     * @generated from protobuf field: repeated taskqueue.WorkerDetails workers_details = 1
     */
    workersDetails: WorkerDetails[];
}
/**
 * @generated from protobuf message taskqueue.PingAndGetNewTasksRequest
 */
export interface PingAndGetNewTasksRequest {
    /**
     * @generated from protobuf field: int32 worker_id = 1
     */
    workerId: number;
    /**
     * @generated from protobuf field: taskqueue.WorkerStats stats = 2
     */
    stats?: WorkerStats; // Optional
}
/**
 * @generated from protobuf message taskqueue.Ack
 */
export interface Ack {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
}
/**
 * @generated from protobuf message taskqueue.ListTasksRequest
 */
export interface ListTasksRequest {
    /**
     * @generated from protobuf field: optional string status_filter = 1
     */
    statusFilter?: string;
    /**
     * @generated from protobuf field: optional int32 worker_id_filter = 2
     */
    workerIdFilter?: number;
    /**
     * @generated from protobuf field: optional int32 workflow_id_filter = 3
     */
    workflowIdFilter?: number;
    /**
     * @generated from protobuf field: optional int32 step_id_filter = 4
     */
    stepIdFilter?: number;
    /**
     * @generated from protobuf field: optional string command_filter = 5
     */
    commandFilter?: string;
    /**
     * @generated from protobuf field: optional int32 limit = 6
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional int32 offset = 7
     */
    offset?: number;
    /**
     * @generated from protobuf field: optional bool show_hidden = 8
     */
    showHidden?: boolean;
}
/**
 * @generated from protobuf message taskqueue.WorkerRequest
 */
export interface WorkerRequest {
    /**
     * @generated from protobuf field: int32 provider_id = 1
     */
    providerId: number;
    /**
     * @generated from protobuf field: int32 flavor_id = 2
     */
    flavorId: number;
    /**
     * @generated from protobuf field: int32 region_id = 3
     */
    regionId: number;
    /**
     * @generated from protobuf field: int32 number = 4
     */
    number: number;
    /**
     * @generated from protobuf field: int32 concurrency = 5
     */
    concurrency: number;
    /**
     * @generated from protobuf field: int32 prefetch = 6
     */
    prefetch: number;
    /**
     * @generated from protobuf field: optional int32 step_id = 7
     */
    stepId?: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerUpdateRequest
 */
export interface WorkerUpdateRequest {
    /**
     * @generated from protobuf field: int32 worker_id = 1
     */
    workerId: number;
    /**
     * @generated from protobuf field: optional int32 provider_id = 2
     */
    providerId?: number;
    /**
     * @generated from protobuf field: optional int32 flavor_id = 3
     */
    flavorId?: number;
    /**
     * @generated from protobuf field: optional int32 region_id = 4
     */
    regionId?: number;
    /**
     * @generated from protobuf field: optional int32 concurrency = 5
     */
    concurrency?: number;
    /**
     * @generated from protobuf field: optional int32 prefetch = 6
     */
    prefetch?: number;
    /**
     * @generated from protobuf field: optional int32 step_id = 7
     */
    stepId?: number;
    /**
     * @generated from protobuf field: optional bool is_permanent = 8
     */
    isPermanent?: boolean;
    /**
     * @generated from protobuf field: optional string recyclable_scope = 9
     */
    recyclableScope?: string;
}
/**
 * @generated from protobuf message taskqueue.ListFlavorsRequest
 */
export interface ListFlavorsRequest {
    /**
     * @generated from protobuf field: int32 limit = 1
     */
    limit: number;
    /**
     * @generated from protobuf field: string filter = 2
     */
    filter: string;
}
/**
 * @generated from protobuf message taskqueue.Flavor
 */
export interface Flavor {
    /**
     * Fields from the "flavor" table
     *
     * @generated from protobuf field: int32 flavor_id = 1
     */
    flavorId: number; // PRIMARY KEY
    /**
     * @generated from protobuf field: string flavor_name = 2
     */
    flavorName: string; // Name of the flavor
    /**
     * @generated from protobuf field: int32 provider_id = 3
     */
    providerId: number; // Foreign key to provider table
    /**
     * @generated from protobuf field: string provider = 4
     */
    provider: string; // Name of the provider (provider_name.config_name)
    /**
     * @generated from protobuf field: int32 cpu = 5
     */
    cpu: number; // Number of CPU cores
    /**
     * @generated from protobuf field: float mem = 6
     */
    mem: number; // Memory in GB (or as needed)
    /**
     * @generated from protobuf field: float disk = 7
     */
    disk: number; // Disk size in GB (or as needed)
    /**
     * @generated from protobuf field: int32 bandwidth = 8
     */
    bandwidth: number; // Bandwidth (if applicable)
    /**
     * @generated from protobuf field: string gpu = 9
     */
    gpu: string; // GPU description
    /**
     * @generated from protobuf field: int32 gpumem = 10
     */
    gpumem: number; // GPU memory (in GB, for example)
    /**
     * @generated from protobuf field: bool has_gpu = 11
     */
    hasGpu: boolean; // Whether a GPU is present
    /**
     * @generated from protobuf field: bool has_quick_disks = 12
     */
    hasQuickDisks: boolean; // Whether quick disks are supported
    /**
     * Fields from the "flavor_region" table
     *
     * @generated from protobuf field: int32 region_id = 13
     */
    regionId: number; // Foreign key to region table
    /**
     * @generated from protobuf field: string region = 14
     */
    region: string; // (Optional) Region name
    /**
     * @generated from protobuf field: float eviction = 15
     */
    eviction: number; // Eviction rate value
    /**
     * @generated from protobuf field: float cost = 16
     */
    cost: number; // Cost value
}
/**
 * @generated from protobuf message taskqueue.FlavorsList
 */
export interface FlavorsList {
    /**
     * @generated from protobuf field: repeated taskqueue.Flavor flavors = 1
     */
    flavors: Flavor[];
}
/**
 * @generated from protobuf message taskqueue.ListJobsRequest
 */
export interface ListJobsRequest {
    /**
     * @generated from protobuf field: optional int32 limit = 1
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional int32 offset = 2
     */
    offset?: number;
}
/**
 * @generated from protobuf message taskqueue.Job
 */
export interface Job {
    /**
     * @generated from protobuf field: int32 job_id = 1
     */
    jobId: number;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
    /**
     * @generated from protobuf field: int32 flavor_id = 3
     */
    flavorId: number;
    /**
     * @generated from protobuf field: int32 retry = 4
     */
    retry: number;
    /**
     * @generated from protobuf field: int32 worker_id = 5
     */
    workerId: number;
    /**
     * @generated from protobuf field: string action = 6
     */
    action: string;
    /**
     * @generated from protobuf field: string created_at = 7
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string modified_at = 8
     */
    modifiedAt: string;
    /**
     * @generated from protobuf field: int32 progression = 9
     */
    progression: number;
    /**
     * @generated from protobuf field: string log = 10
     */
    log: string;
}
/**
 * @generated from protobuf message taskqueue.JobId
 */
export interface JobId {
    /**
     * @generated from protobuf field: int32 job_id = 1
     */
    jobId: number;
}
/**
 * @generated from protobuf message taskqueue.JobsList
 */
export interface JobsList {
    /**
     * @generated from protobuf field: repeated taskqueue.Job jobs = 1
     */
    jobs: Job[];
}
/**
 * @generated from protobuf message taskqueue.JobStatusRequest
 */
export interface JobStatusRequest {
    /**
     * @generated from protobuf field: repeated int32 job_ids = 1
     */
    jobIds: number[];
}
/**
 * @generated from protobuf message taskqueue.JobStatus
 */
export interface JobStatus {
    /**
     * @generated from protobuf field: int32 job_id = 1
     */
    jobId: number;
    /**
     * @generated from protobuf field: string status = 2
     */
    status: string;
    /**
     * @generated from protobuf field: int32 progression = 3
     */
    progression: number;
}
/**
 * @generated from protobuf message taskqueue.JobStatusResponse
 */
export interface JobStatusResponse {
    /**
     * @generated from protobuf field: repeated taskqueue.JobStatus statuses = 1
     */
    statuses: JobStatus[];
}
/**
 * @generated from protobuf message taskqueue.JobUpdate
 */
export interface JobUpdate {
    /**
     * @generated from protobuf field: int32 job_id = 1
     */
    jobId: number; // which job to update
    /**
     * @generated from protobuf field: optional string status = 2
     */
    status?: string; // 'P'|'R'|'S'|'F'|'X' (only if you want to set it)
    /**
     * @generated from protobuf field: optional string append_log = 3
     */
    appendLog?: string; // text appended to job.log (server prepends timestamp)
    /**
     * @generated from protobuf field: optional int32 progression = 4
     */
    progression?: number; // 0..100 (server clamps)
}
/**
 * @generated from protobuf message taskqueue.RcloneRemotes
 */
export interface RcloneRemotes {
    /**
     * @generated from protobuf field: map<string, taskqueue.RcloneRemote> remotes = 1
     */
    remotes: {
        [key: string]: RcloneRemote;
    };
}
/**
 * @generated from protobuf message taskqueue.RcloneRemote
 */
export interface RcloneRemote {
    /**
     * @generated from protobuf field: map<string, string> options = 1
     */
    options: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message taskqueue.DockerCredential
 */
export interface DockerCredential {
    /**
     * @generated from protobuf field: string registry = 1
     */
    registry: string; // e.g., "3jfz1gy8.gra7.container-registry.ovh.net"
    /**
     * @generated from protobuf field: string auth = 2
     */
    auth: string; // auth string as found in .docker/config.json
}
/**
 * @generated from protobuf message taskqueue.DockerCredentials
 */
export interface DockerCredentials {
    /**
     * @generated from protobuf field: repeated taskqueue.DockerCredential credentials = 1
     */
    credentials: DockerCredential[];
}
/**
 * @generated from protobuf message taskqueue.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
}
/**
 * @generated from protobuf message taskqueue.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * @generated from protobuf message taskqueue.Token
 */
export interface Token {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * @generated from protobuf message taskqueue.CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
    /**
     * @generated from protobuf field: string email = 3
     */
    email: string;
    /**
     * @generated from protobuf field: bool is_admin = 4
     */
    isAdmin: boolean;
}
/**
 * @generated from protobuf message taskqueue.UserId
 */
export interface UserId {
    /**
     * @generated from protobuf field: int32 user_id = 1
     */
    userId: number;
}
/**
 * @generated from protobuf message taskqueue.User
 */
export interface User {
    /**
     * @generated from protobuf field: int32 user_id = 1
     */
    userId: number;
    /**
     * @generated from protobuf field: optional string username = 2
     */
    username?: string;
    /**
     * @generated from protobuf field: optional string email = 3
     */
    email?: string;
    /**
     * @generated from protobuf field: optional bool is_admin = 4
     */
    isAdmin?: boolean;
}
/**
 * @generated from protobuf message taskqueue.UsersList
 */
export interface UsersList {
    /**
     * @generated from protobuf field: repeated taskqueue.User users = 1
     */
    users: User[];
}
/**
 * @generated from protobuf message taskqueue.ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: string old_password = 2
     */
    oldPassword: string;
    /**
     * @generated from protobuf field: string new_password = 3
     */
    newPassword: string;
}
/**
 * @generated from protobuf message taskqueue.RecruiterFilter
 */
export interface RecruiterFilter {
    /**
     * @generated from protobuf field: optional int32 step_id = 1
     */
    stepId?: number;
}
/**
 * @generated from protobuf message taskqueue.RecruiterId
 */
export interface RecruiterId {
    /**
     * @generated from protobuf field: int32 step_id = 1
     */
    stepId: number;
    /**
     * @generated from protobuf field: int32 rank = 2
     */
    rank: number;
}
/**
 * @generated from protobuf message taskqueue.Recruiter
 */
export interface Recruiter {
    /**
     * @generated from protobuf field: int32 step_id = 1
     */
    stepId: number;
    /**
     * @generated from protobuf field: int32 rank = 2
     */
    rank: number;
    /**
     * @generated from protobuf field: string protofilter = 3
     */
    protofilter: string;
    /**
     * @generated from protobuf field: optional int32 concurrency = 4
     */
    concurrency?: number;
    /**
     * @generated from protobuf field: optional int32 prefetch = 5
     */
    prefetch?: number;
    /**
     * @generated from protobuf field: optional int32 max_workers = 6
     */
    maxWorkers?: number;
    /**
     * @generated from protobuf field: int32 rounds = 7
     */
    rounds: number;
    /**
     * @generated from protobuf field: int32 timeout = 8
     */
    timeout: number;
    /**
     * @generated from protobuf field: optional int32 cpu_per_task = 9
     */
    cpuPerTask?: number;
    /**
     * @generated from protobuf field: optional float memory_per_task = 10
     */
    memoryPerTask?: number;
    /**
     * @generated from protobuf field: optional float disk_per_task = 11
     */
    diskPerTask?: number;
    /**
     * @generated from protobuf field: optional int32 prefetch_percent = 12
     */
    prefetchPercent?: number;
    /**
     * @generated from protobuf field: optional int32 concurrency_min = 13
     */
    concurrencyMin?: number;
    /**
     * @generated from protobuf field: optional int32 concurrency_max = 14
     */
    concurrencyMax?: number;
}
/**
 * @generated from protobuf message taskqueue.RecruiterUpdate
 */
export interface RecruiterUpdate {
    /**
     * @generated from protobuf field: int32 step_id = 1
     */
    stepId: number;
    /**
     * @generated from protobuf field: int32 rank = 2
     */
    rank: number;
    /**
     * @generated from protobuf field: optional string protofilter = 3
     */
    protofilter?: string;
    /**
     * @generated from protobuf field: optional int32 concurrency = 4
     */
    concurrency?: number;
    /**
     * @generated from protobuf field: optional int32 prefetch = 5
     */
    prefetch?: number;
    /**
     * @generated from protobuf field: optional int32 max_workers = 6
     */
    maxWorkers?: number;
    /**
     * @generated from protobuf field: optional int32 rounds = 7
     */
    rounds?: number;
    /**
     * @generated from protobuf field: optional int32 timeout = 8
     */
    timeout?: number;
    /**
     * @generated from protobuf field: optional int32 cpu_per_task = 9
     */
    cpuPerTask?: number;
    /**
     * @generated from protobuf field: optional float memory_per_task = 10
     */
    memoryPerTask?: number;
    /**
     * @generated from protobuf field: optional float disk_per_task = 11
     */
    diskPerTask?: number;
    /**
     * @generated from protobuf field: optional int32 prefetch_percent = 12
     */
    prefetchPercent?: number;
    /**
     * @generated from protobuf field: optional int32 concurrency_min = 13
     */
    concurrencyMin?: number;
    /**
     * @generated from protobuf field: optional int32 concurrency_max = 14
     */
    concurrencyMax?: number;
}
/**
 * @generated from protobuf message taskqueue.RecruiterList
 */
export interface RecruiterList {
    /**
     * @generated from protobuf field: repeated taskqueue.Recruiter recruiters = 1
     */
    recruiters: Recruiter[];
}
/**
 * @generated from protobuf message taskqueue.WorkflowFilter
 */
export interface WorkflowFilter {
    /**
     * @generated from protobuf field: optional string name_like = 1
     */
    nameLike?: string;
    /**
     * @generated from protobuf field: optional int32 limit = 2
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional int32 offset = 3
     */
    offset?: number;
}
/**
 * @generated from protobuf message taskqueue.WorkflowId
 */
export interface WorkflowId {
    /**
     * @generated from protobuf field: int32 workflow_id = 1
     */
    workflowId: number;
}
/**
 * @generated from protobuf message taskqueue.Workflow
 */
export interface Workflow {
    /**
     * @generated from protobuf field: int32 workflow_id = 1
     */
    workflowId: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string run_strategy = 4
     */
    runStrategy: string;
    /**
     * @generated from protobuf field: optional int32 maximum_workers = 5
     */
    maximumWorkers?: number;
}
/**
 * @generated from protobuf message taskqueue.WorkflowRequest
 */
export interface WorkflowRequest {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: optional string run_strategy = 2
     */
    runStrategy?: string;
    /**
     * @generated from protobuf field: optional int32 maximum_workers = 3
     */
    maximumWorkers?: number;
}
/**
 * @generated from protobuf message taskqueue.WorkflowList
 */
export interface WorkflowList {
    /**
     * @generated from protobuf field: repeated taskqueue.Workflow workflows = 1
     */
    workflows: Workflow[];
}
/**
 * @generated from protobuf message taskqueue.StepFilter
 */
export interface StepFilter {
    /**
     * @generated from protobuf field: int32 WorkflowId = 1
     */
    workflowId: number;
    /**
     * @generated from protobuf field: optional int32 limit = 2
     */
    limit?: number;
    /**
     * @generated from protobuf field: optional int32 offset = 3
     */
    offset?: number;
}
/**
 * @generated from protobuf message taskqueue.StepId
 */
export interface StepId {
    /**
     * @generated from protobuf field: int32 step_id = 1
     */
    stepId: number;
}
/**
 * @generated from protobuf message taskqueue.Step
 */
export interface Step {
    /**
     * @generated from protobuf field: int32 step_id = 1
     */
    stepId: number;
    /**
     * @generated from protobuf field: string workflow_name = 2
     */
    workflowName: string;
    /**
     * @generated from protobuf field: int32 workflow_id = 3
     */
    workflowId: number;
    /**
     * @generated from protobuf field: string name = 4
     */
    name: string;
}
/**
 * @generated from protobuf message taskqueue.StepRequest
 */
export interface StepRequest {
    /**
     * @generated from protobuf field: optional string workflow_name = 1
     */
    workflowName?: string;
    /**
     * @generated from protobuf field: optional int32 workflow_id = 2
     */
    workflowId?: number;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
}
/**
 * @generated from protobuf message taskqueue.StepList
 */
export interface StepList {
    /**
     * @generated from protobuf field: repeated taskqueue.Step steps = 1
     */
    steps: Step[];
}
/**
 * @generated from protobuf message taskqueue.StepStatsRequest
 */
export interface StepStatsRequest {
    /**
     * @generated from protobuf field: optional int32 workflow_id = 1
     */
    workflowId?: number;
    /**
     * @generated from protobuf field: repeated int32 step_ids = 2
     */
    stepIds: number[];
}
/**
 * @generated from protobuf message taskqueue.Accum
 */
export interface Accum {
    /**
     * @generated from protobuf field: int32 count = 1
     */
    count: number; // number of observations
    /**
     * @generated from protobuf field: float sum = 2
     */
    sum: number; // total seconds
    /**
     * @generated from protobuf field: float min = 3
     */
    min: number; // minimum seconds
    /**
     * @generated from protobuf field: float max = 4
     */
    max: number; // maximum seconds
}
/**
 * @generated from protobuf message taskqueue.StepStats
 */
export interface StepStats {
    /**
     * @generated from protobuf field: int32 step_id = 1
     */
    stepId: number;
    /**
     * @generated from protobuf field: string step_name = 2
     */
    stepName: string;
    /**
     * @generated from protobuf field: int32 total_tasks = 3
     */
    totalTasks: number;
    /**
     * @generated from protobuf field: int32 waiting_tasks = 4
     */
    waitingTasks: number;
    /**
     * @generated from protobuf field: int32 pending_tasks = 5
     */
    pendingTasks: number;
    /**
     * @generated from protobuf field: int32 accepted_tasks = 6
     */
    acceptedTasks: number;
    /**
     * @generated from protobuf field: int32 running_tasks = 7
     */
    runningTasks: number;
    /**
     * @generated from protobuf field: int32 uploading_tasks = 8
     */
    uploadingTasks: number;
    /**
     * @generated from protobuf field: int32 successful_tasks = 9
     */
    successfulTasks: number;
    /**
     * @generated from protobuf field: int32 failed_tasks = 10
     */
    failedTasks: number;
    /**
     * @generated from protobuf field: int32 really_failed_tasks = 11
     */
    reallyFailedTasks: number; // tasks that have exhausted all retries and are failed
    /**
     * @generated from protobuf field: taskqueue.Accum success_run = 12
     */
    successRun?: Accum; // succeeded tasks' run durations
    /**
     * @generated from protobuf field: taskqueue.Accum failed_run = 13
     */
    failedRun?: Accum; // failed tasks' run durations
    /**
     * @generated from protobuf field: taskqueue.Accum running_run = 14
     */
    runningRun?: Accum; // running tasks' elapsed durations (at eval time)
    /**
     * @generated from protobuf field: taskqueue.Accum download = 15
     */
    download?: Accum; // download durations
    /**
     * @generated from protobuf field: taskqueue.Accum upload = 16
     */
    upload?: Accum; // upload durations
    /**
     * @generated from protobuf field: optional int64 start_time = 17
     */
    startTime?: string; // epoch timestamp of the first task start time
    /**
     * @generated from protobuf field: optional int64 end_time = 18
     */
    endTime?: string; // epoch timestamp of the last task end time
    /**
     * @generated from protobuf field: int32 stats_eval_time = 19
     */
    statsEvalTime: number; // epoch seconds when these stats were computed
}
/**
 * @generated from protobuf message taskqueue.StepStatsResponse
 */
export interface StepStatsResponse {
    /**
     * @generated from protobuf field: repeated taskqueue.StepStats stats = 1
     */
    stats: StepStats[];
}
/**
 * @generated from protobuf message taskqueue.WorkerStats
 */
export interface WorkerStats {
    /**
     * @generated from protobuf field: float cpu_usage_percent = 1
     */
    cpuUsagePercent: number; // 0-100, float
    /**
     * @generated from protobuf field: float mem_usage_percent = 2
     */
    memUsagePercent: number; // 0-100, float
    /**
     * @generated from protobuf field: float load_1min = 3
     */
    load1Min: number; // e.g., 0.58, float
    /**
     * @generated from protobuf field: float iowait_percent = 4
     */
    iowaitPercent: number; // 0-100 float 
    /**
     * @generated from protobuf field: repeated taskqueue.DiskUsage disks = 5
     */
    disks: DiskUsage[]; // Per-disk usage
    /**
     * @generated from protobuf field: taskqueue.DiskIOStats disk_io = 6
     */
    diskIo?: DiskIOStats; // Global disk IO (aggregated)
    /**
     * @generated from protobuf field: taskqueue.NetIOStats net_io = 7
     */
    netIo?: NetIOStats; // Global network IO (aggregated)
}
/**
 * @generated from protobuf message taskqueue.DiskUsage
 */
export interface DiskUsage {
    /**
     * @generated from protobuf field: string device_name = 1
     */
    deviceName: string; // E.g., "/dev/sda1"
    /**
     * @generated from protobuf field: float usage_percent = 2
     */
    usagePercent: number; // 0-100, float
}
/**
 * @generated from protobuf message taskqueue.DiskIOStats
 */
export interface DiskIOStats {
    /**
     * @generated from protobuf field: int64 read_bytes_total = 1
     */
    readBytesTotal: string; // Total bytes read
    /**
     * @generated from protobuf field: int64 write_bytes_total = 2
     */
    writeBytesTotal: string; // Total bytes written
    /**
     * @generated from protobuf field: float read_bytes_rate = 3
     */
    readBytesRate: number; // Bytes per second
    /**
     * @generated from protobuf field: float write_bytes_rate = 4
     */
    writeBytesRate: number; // Bytes per second
}
/**
 * @generated from protobuf message taskqueue.NetIOStats
 */
export interface NetIOStats {
    /**
     * @generated from protobuf field: int64 recv_bytes_total = 1
     */
    recvBytesTotal: string; // Total bytes received
    /**
     * @generated from protobuf field: int64 sent_bytes_total = 2
     */
    sentBytesTotal: string; // Total bytes sent
    /**
     * @generated from protobuf field: float recv_bytes_rate = 3
     */
    recvBytesRate: number; // Bytes per second
    /**
     * @generated from protobuf field: float sent_bytes_rate = 4
     */
    sentBytesRate: number; // Bytes per second
}
/**
 * @generated from protobuf message taskqueue.GetWorkerStatsRequest
 */
export interface GetWorkerStatsRequest {
    /**
     * @generated from protobuf field: repeated int32 worker_ids = 1
     */
    workerIds: number[];
}
/**
 * @generated from protobuf message taskqueue.GetWorkerStatsResponse
 */
export interface GetWorkerStatsResponse {
    /**
     * @generated from protobuf field: map<int32, taskqueue.WorkerStats> worker_stats = 1
     */
    workerStats: {
        [key: number]: WorkerStats;
    };
}
/**
 * @generated from protobuf message taskqueue.FetchListRequest
 */
export interface FetchListRequest {
    /**
     * @generated from protobuf field: string uri = 1
     */
    uri: string; // URI to fetch the list from (can include glob patterns)
}
/**
 * @generated from protobuf message taskqueue.FetchListResponse
 */
export interface FetchListResponse {
    /**
     * @generated from protobuf field: repeated string files = 1
     */
    files: string[]; // Absolute paths from the given URI
}
/**
 * @generated from protobuf message taskqueue.FetchInfoResponse
 */
export interface FetchInfoResponse {
    /**
     * @generated from protobuf field: string uri = 1
     */
    uri: string;
    /**
     * @generated from protobuf field: string filename = 2
     */
    filename: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: int64 size = 4
     */
    size: string;
    /**
     * @generated from protobuf field: bool is_file = 5
     */
    isFile: boolean;
    /**
     * @generated from protobuf field: bool is_dir = 6
     */
    isDir: boolean;
}
/**
 * @generated from protobuf message taskqueue.UploadTemplateRequest
 */
export interface UploadTemplateRequest {
    /**
     * @generated from protobuf field: bytes script = 1
     */
    script: Uint8Array;
    /**
     * @generated from protobuf field: bool force = 2
     */
    force: boolean;
}
/**
 * @generated from protobuf message taskqueue.UploadTemplateResponse
 */
export interface UploadTemplateResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: optional int32 workflow_template_id = 3
     */
    workflowTemplateId?: number;
    /**
     * @generated from protobuf field: optional string name = 4
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string version = 5
     */
    version?: string;
    /**
     * @generated from protobuf field: optional string description = 6
     */
    description?: string;
    /**
     * @generated from protobuf field: optional string param_json = 7
     */
    paramJson?: string;
}
/**
 * @generated from protobuf message taskqueue.RunTemplateRequest
 */
export interface RunTemplateRequest {
    /**
     * @generated from protobuf field: int32 workflow_template_id = 1
     */
    workflowTemplateId: number;
    /**
     * @generated from protobuf field: string param_values_json = 2
     */
    paramValuesJson: string;
}
/**
 * @generated from protobuf message taskqueue.TemplateFilter
 */
export interface TemplateFilter {
    /**
     * @generated from protobuf field: optional int32 workflow_template_id = 1
     */
    workflowTemplateId?: number;
    /**
     * @generated from protobuf field: optional string name = 2
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string version = 3
     */
    version?: string;
}
/**
 * @generated from protobuf message taskqueue.Template
 */
export interface Template {
    /**
     * @generated from protobuf field: int32 workflow_template_id = 1
     */
    workflowTemplateId: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string version = 3
     */
    version: string;
    /**
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * @generated from protobuf field: string param_json = 5
     */
    paramJson: string;
    /**
     * @generated from protobuf field: string uploaded_at = 6
     */
    uploadedAt: string;
    /**
     * @generated from protobuf field: optional int32 uploaded_by = 7
     */
    uploadedBy?: number;
}
/**
 * @generated from protobuf message taskqueue.TemplateList
 */
export interface TemplateList {
    /**
     * @generated from protobuf field: repeated taskqueue.Template templates = 1
     */
    templates: Template[];
}
/**
 * @generated from protobuf message taskqueue.TemplateRun
 */
export interface TemplateRun {
    /**
     * @generated from protobuf field: int32 template_run_id = 1
     */
    templateRunId: number;
    /**
     * @generated from protobuf field: int32 workflow_template_id = 2
     */
    workflowTemplateId: number;
    /**
     * @generated from protobuf field: optional string template_name = 3
     */
    templateName?: string;
    /**
     * @generated from protobuf field: optional string template_version = 4
     */
    templateVersion?: string;
    /**
     * @generated from protobuf field: optional string workflow_name = 5
     */
    workflowName?: string;
    /**
     * @generated from protobuf field: optional int32 run_by = 6
     */
    runBy?: number;
    /**
     * @generated from protobuf field: string status = 7
     */
    status: string;
    /**
     * @generated from protobuf field: optional int32 workflow_id = 8
     */
    workflowId?: number;
    /**
     * @generated from protobuf field: string created_at = 9
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string param_values_json = 10
     */
    paramValuesJson: string;
    /**
     * @generated from protobuf field: optional string error_message = 11
     */
    errorMessage?: string;
    /**
     * @generated from protobuf field: optional string run_by_username = 12
     */
    runByUsername?: string;
}
/**
 * @generated from protobuf message taskqueue.TemplateRunList
 */
export interface TemplateRunList {
    /**
     * @generated from protobuf field: repeated taskqueue.TemplateRun runs = 1
     */
    runs: TemplateRun[];
}
/**
 * @generated from protobuf message taskqueue.TemplateRunFilter
 */
export interface TemplateRunFilter {
    /**
     * @generated from protobuf field: optional int32 workflow_template_id = 1
     */
    workflowTemplateId?: number;
}
/**
 * @generated from protobuf message taskqueue.UpdateTemplateRunRequest
 */
export interface UpdateTemplateRunRequest {
    /**
     * @generated from protobuf field: int32 template_run_id = 1
     */
    templateRunId: number;
    /**
     * @generated from protobuf field: optional int32 workflow_id = 2
     */
    workflowId?: number;
    /**
     * @generated from protobuf field: optional string error_message = 3
     */
    errorMessage?: string;
}
/**
 * @generated from protobuf message taskqueue.WorkspaceRootRequest
 */
export interface WorkspaceRootRequest {
    /**
     * @generated from protobuf field: string provider = 1
     */
    provider: string; // e.g., "azure.default" or "openstack.ovh"
    /**
     * @generated from protobuf field: string region = 2
     */
    region: string; // e.g., "northeurope"
}
/**
 * @generated from protobuf message taskqueue.WorkspaceRootResponse
 */
export interface WorkspaceRootResponse {
    /**
     * @generated from protobuf field: string root_uri = 1
     */
    rootUri: string; // e.g., "aznorth://workspace"
}
/**
 * @generated from protobuf message taskqueue.DeleteTemplateRunRequest
 */
export interface DeleteTemplateRunRequest {
    /**
     * @generated from protobuf field: int32 template_run_id = 1
     */
    templateRunId: number;
}
/**
 * @generated from protobuf message taskqueue.ResourceSpec
 */
export interface ResourceSpec {
    /**
     * @generated from protobuf field: string worker_id = 1
     */
    workerId: string;
    /**
     * @generated from protobuf field: int32 cpu = 2
     */
    cpu: number;
    /**
     * @generated from protobuf field: float mem = 3
     */
    mem: number;
    /**
     * @generated from protobuf field: float disk = 4
     */
    disk: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerEvent
 */
export interface WorkerEvent {
    /**
     * optional because a worker may fail before registration
     *
     * @generated from protobuf field: optional int32 worker_id = 1
     */
    workerId?: number;
    /**
     * @generated from protobuf field: string worker_name = 2
     */
    workerName: string; // free text (hostname or generated name)
    /**
     * @generated from protobuf field: string level = 3
     */
    level: string; // single letter: D/I/W/E
    /**
     * @generated from protobuf field: string event_class = 4
     */
    eventClass: string; // e.g. "install", "bootstrap", "runtime", "network"
    /**
     * @generated from protobuf field: string message = 5
     */
    message: string; // short human description
    /**
     * @generated from protobuf field: string details_json = 6
     */
    detailsJson: string; // raw JSON string (optional)
}
/**
 * @generated from protobuf message taskqueue.WorkerEventFilter
 */
export interface WorkerEventFilter {
    /**
     * @generated from protobuf field: optional int32 worker_id = 1
     */
    workerId?: number;
    /**
     * @generated from protobuf field: optional string level = 2
     */
    level?: string; // 'D','I','W','E'
    /**
     * @generated from protobuf field: optional string class = 3
     */
    class?: string; // event_class filter
    /**
     * @generated from protobuf field: optional int32 limit = 4
     */
    limit?: number; // max number of events (default 50)
}
/**
 * @generated from protobuf message taskqueue.WorkerEventRecord
 */
export interface WorkerEventRecord {
    /**
     * @generated from protobuf field: int32 event_id = 1
     */
    eventId: number;
    /**
     * @generated from protobuf field: string created_at = 2
     */
    createdAt: string;
    /**
     * @generated from protobuf field: optional int32 worker_id = 3
     */
    workerId?: number;
    /**
     * @generated from protobuf field: string worker_name = 4
     */
    workerName: string;
    /**
     * @generated from protobuf field: string level = 5
     */
    level: string;
    /**
     * @generated from protobuf field: string event_class = 6
     */
    eventClass: string;
    /**
     * @generated from protobuf field: string message = 7
     */
    message: string;
    /**
     * @generated from protobuf field: string details_json = 8
     */
    detailsJson: string;
}
/**
 * @generated from protobuf message taskqueue.WorkerEventList
 */
export interface WorkerEventList {
    /**
     * @generated from protobuf field: repeated taskqueue.WorkerEventRecord events = 1
     */
    events: WorkerEventRecord[];
}
/**
 * @generated from protobuf message taskqueue.WorkerEventId
 */
export interface WorkerEventId {
    /**
     * @generated from protobuf field: int32 event_id = 1
     */
    eventId: number;
}
/**
 * @generated from protobuf message taskqueue.WorkerEventPruneFilter
 */
export interface WorkerEventPruneFilter {
    /**
     * @generated from protobuf field: optional string before = 1
     */
    before?: string; // RFC3339 UTC, e.g. "2025-08-19T00:00:00Z"
    /**
     * @generated from protobuf field: optional string level = 2
     */
    level?: string; // 'D'|'I'|'W'|'E'
    /**
     * @generated from protobuf field: optional string class = 3
     */
    class?: string; // event_class exact match
    /**
     * @generated from protobuf field: optional int32 worker_id = 4
     */
    workerId?: number;
    /**
     * @generated from protobuf field: bool dry_run = 5
     */
    dryRun: boolean; // if true, count only; no deletion
}
/**
 * @generated from protobuf message taskqueue.WorkerEventPruneResult
 */
export interface WorkerEventPruneResult {
    /**
     * @generated from protobuf field: int32 matched = 1
     */
    matched: number;
    /**
     * @generated from protobuf field: int32 deleted = 2
     */
    deleted: number;
}
/**
 * @generated from protobuf message taskqueue.Provider
 */
export interface Provider {
    /**
     * @generated from protobuf field: int32 provider_id = 1
     */
    providerId: number;
    /**
     * @generated from protobuf field: string provider_name = 2
     */
    providerName: string;
    /**
     * @generated from protobuf field: string config_name = 3
     */
    configName: string;
}
/**
 * @generated from protobuf message taskqueue.ProviderList
 */
export interface ProviderList {
    /**
     * @generated from protobuf field: repeated taskqueue.Provider providers = 1
     */
    providers: Provider[];
}
/**
 * @generated from protobuf message taskqueue.Region
 */
export interface Region {
    /**
     * @generated from protobuf field: int32 region_id = 1
     */
    regionId: number;
    /**
     * @generated from protobuf field: int32 provider_id = 2
     */
    providerId: number;
    /**
     * @generated from protobuf field: string region_name = 3
     */
    regionName: string;
    /**
     * @generated from protobuf field: bool is_default = 4
     */
    isDefault: boolean;
}
/**
 * @generated from protobuf message taskqueue.RegionList
 */
export interface RegionList {
    /**
     * @generated from protobuf field: repeated taskqueue.Region regions = 1
     */
    regions: Region[];
}
/**
 * @generated from protobuf message taskqueue.FlavorCreateRequest
 */
export interface FlavorCreateRequest {
    /**
     * @generated from protobuf field: string provider_name = 1
     */
    providerName: string;
    /**
     * @generated from protobuf field: string config_name = 2
     */
    configName: string;
    /**
     * @generated from protobuf field: string flavor_name = 3
     */
    flavorName: string;
    /**
     * @generated from protobuf field: int32 cpu = 4
     */
    cpu: number;
    /**
     * @generated from protobuf field: float memory = 5
     */
    memory: number;
    /**
     * @generated from protobuf field: float disk = 6
     */
    disk: number;
    /**
     * @generated from protobuf field: optional int32 bandwidth = 7
     */
    bandwidth?: number;
    /**
     * @generated from protobuf field: optional string gpu = 8
     */
    gpu?: string;
    /**
     * @generated from protobuf field: optional int32 gpumem = 9
     */
    gpumem?: number;
    /**
     * @generated from protobuf field: optional bool has_gpu = 10
     */
    hasGpu?: boolean;
    /**
     * @generated from protobuf field: optional bool has_quick_disks = 11
     */
    hasQuickDisks?: boolean;
    /**
     * @generated from protobuf field: repeated string region_names = 12
     */
    regionNames: string[];
    /**
     * @generated from protobuf field: repeated float costs = 13
     */
    costs: number[];
    /**
     * @generated from protobuf field: repeated float evictions = 14
     */
    evictions: number[];
}
/**
 * @generated from protobuf message taskqueue.FlavorId
 */
export interface FlavorId {
    /**
     * @generated from protobuf field: int32 flavor_id = 1
     */
    flavorId: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class TaskResponse$Type extends MessageType<TaskResponse> {
    constructor() {
        super("taskqueue.TaskResponse", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskResponse>): TaskResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskResponse): TaskResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskResponse
 */
export const TaskResponse = new TaskResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerInfo$Type extends MessageType<WorkerInfo> {
    constructor() {
        super("taskqueue.WorkerInfo", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "concurrency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "is_permanent", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "provider", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "region", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerInfo>): WorkerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WorkerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerInfo): WorkerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional int32 concurrency */ 2:
                    message.concurrency = reader.int32();
                    break;
                case /* optional bool is_permanent */ 3:
                    message.isPermanent = reader.bool();
                    break;
                case /* optional string provider */ 4:
                    message.provider = reader.string();
                    break;
                case /* optional string region */ 5:
                    message.region = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional int32 concurrency = 2; */
        if (message.concurrency !== undefined)
            writer.tag(2, WireType.Varint).int32(message.concurrency);
        /* optional bool is_permanent = 3; */
        if (message.isPermanent !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isPermanent);
        /* optional string provider = 4; */
        if (message.provider !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.provider);
        /* optional string region = 5; */
        if (message.region !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.region);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerInfo
 */
export const WorkerInfo = new WorkerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskRequest$Type extends MessageType<TaskRequest> {
    constructor() {
        super("taskqueue.TaskRequest", [
            { no: 1, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "shell", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "container", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "container_options", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "step_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "input", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "resource", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "output", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "retry", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "is_final", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "uses_cache", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "download_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "running_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "upload_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "dependency", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "task_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskRequest>): TaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = "";
        message.container = "";
        message.input = [];
        message.resource = [];
        message.status = "";
        message.dependency = [];
        if (value !== undefined)
            reflectionMergePartial<TaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskRequest): TaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string command */ 1:
                    message.command = reader.string();
                    break;
                case /* optional string shell */ 2:
                    message.shell = reader.string();
                    break;
                case /* string container */ 3:
                    message.container = reader.string();
                    break;
                case /* optional string container_options */ 4:
                    message.containerOptions = reader.string();
                    break;
                case /* optional int32 step_id */ 5:
                    message.stepId = reader.int32();
                    break;
                case /* repeated string input */ 6:
                    message.input.push(reader.string());
                    break;
                case /* repeated string resource */ 7:
                    message.resource.push(reader.string());
                    break;
                case /* optional string output */ 8:
                    message.output = reader.string();
                    break;
                case /* optional int32 retry */ 9:
                    message.retry = reader.int32();
                    break;
                case /* optional bool is_final */ 10:
                    message.isFinal = reader.bool();
                    break;
                case /* optional bool uses_cache */ 11:
                    message.usesCache = reader.bool();
                    break;
                case /* optional float download_timeout */ 12:
                    message.downloadTimeout = reader.float();
                    break;
                case /* optional float running_timeout */ 13:
                    message.runningTimeout = reader.float();
                    break;
                case /* optional float upload_timeout */ 14:
                    message.uploadTimeout = reader.float();
                    break;
                case /* string status */ 15:
                    message.status = reader.string();
                    break;
                case /* repeated int32 dependency */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dependency.push(reader.int32());
                    else
                        message.dependency.push(reader.int32());
                    break;
                case /* optional string task_name */ 17:
                    message.taskName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string command = 1; */
        if (message.command !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.command);
        /* optional string shell = 2; */
        if (message.shell !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.shell);
        /* string container = 3; */
        if (message.container !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.container);
        /* optional string container_options = 4; */
        if (message.containerOptions !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.containerOptions);
        /* optional int32 step_id = 5; */
        if (message.stepId !== undefined)
            writer.tag(5, WireType.Varint).int32(message.stepId);
        /* repeated string input = 6; */
        for (let i = 0; i < message.input.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.input[i]);
        /* repeated string resource = 7; */
        for (let i = 0; i < message.resource.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.resource[i]);
        /* optional string output = 8; */
        if (message.output !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.output);
        /* optional int32 retry = 9; */
        if (message.retry !== undefined)
            writer.tag(9, WireType.Varint).int32(message.retry);
        /* optional bool is_final = 10; */
        if (message.isFinal !== undefined)
            writer.tag(10, WireType.Varint).bool(message.isFinal);
        /* optional bool uses_cache = 11; */
        if (message.usesCache !== undefined)
            writer.tag(11, WireType.Varint).bool(message.usesCache);
        /* optional float download_timeout = 12; */
        if (message.downloadTimeout !== undefined)
            writer.tag(12, WireType.Bit32).float(message.downloadTimeout);
        /* optional float running_timeout = 13; */
        if (message.runningTimeout !== undefined)
            writer.tag(13, WireType.Bit32).float(message.runningTimeout);
        /* optional float upload_timeout = 14; */
        if (message.uploadTimeout !== undefined)
            writer.tag(14, WireType.Bit32).float(message.uploadTimeout);
        /* string status = 15; */
        if (message.status !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.status);
        /* repeated int32 dependency = 16; */
        if (message.dependency.length) {
            writer.tag(16, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dependency.length; i++)
                writer.int32(message.dependency[i]);
            writer.join();
        }
        /* optional string task_name = 17; */
        if (message.taskName !== undefined)
            writer.tag(17, WireType.LengthDelimited).string(message.taskName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskRequest
 */
export const TaskRequest = new TaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("taskqueue.Task", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "shell", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "container", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "container_options", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "step_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "input", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "resource", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "output", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "retry", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "is_final", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "uses_cache", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "download_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "running_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 15, name: "upload_timeout", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "worker_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "workflow_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "task_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "retry_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "previous_task_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "weight", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 24, name: "run_start_time", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.command = "";
        message.container = "";
        message.input = [];
        message.resource = [];
        message.status = "";
        message.retryCount = 0;
        message.hidden = false;
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* string command */ 2:
                    message.command = reader.string();
                    break;
                case /* optional string shell */ 3:
                    message.shell = reader.string();
                    break;
                case /* string container */ 4:
                    message.container = reader.string();
                    break;
                case /* optional string container_options */ 5:
                    message.containerOptions = reader.string();
                    break;
                case /* optional int32 step_id */ 6:
                    message.stepId = reader.int32();
                    break;
                case /* repeated string input */ 7:
                    message.input.push(reader.string());
                    break;
                case /* repeated string resource */ 8:
                    message.resource.push(reader.string());
                    break;
                case /* optional string output */ 9:
                    message.output = reader.string();
                    break;
                case /* optional int32 retry */ 10:
                    message.retry = reader.int32();
                    break;
                case /* optional bool is_final */ 11:
                    message.isFinal = reader.bool();
                    break;
                case /* optional bool uses_cache */ 12:
                    message.usesCache = reader.bool();
                    break;
                case /* optional float download_timeout */ 13:
                    message.downloadTimeout = reader.float();
                    break;
                case /* optional float running_timeout */ 14:
                    message.runningTimeout = reader.float();
                    break;
                case /* optional float upload_timeout */ 15:
                    message.uploadTimeout = reader.float();
                    break;
                case /* string status */ 16:
                    message.status = reader.string();
                    break;
                case /* optional int32 worker_id */ 17:
                    message.workerId = reader.int32();
                    break;
                case /* optional int32 workflow_id */ 18:
                    message.workflowId = reader.int32();
                    break;
                case /* optional string task_name */ 19:
                    message.taskName = reader.string();
                    break;
                case /* int32 retry_count */ 20:
                    message.retryCount = reader.int32();
                    break;
                case /* bool hidden */ 21:
                    message.hidden = reader.bool();
                    break;
                case /* optional int32 previous_task_id */ 22:
                    message.previousTaskId = reader.int32();
                    break;
                case /* optional double weight */ 23:
                    message.weight = reader.double();
                    break;
                case /* optional int64 run_start_time */ 24:
                    message.runStartTime = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* string command = 2; */
        if (message.command !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.command);
        /* optional string shell = 3; */
        if (message.shell !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.shell);
        /* string container = 4; */
        if (message.container !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.container);
        /* optional string container_options = 5; */
        if (message.containerOptions !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.containerOptions);
        /* optional int32 step_id = 6; */
        if (message.stepId !== undefined)
            writer.tag(6, WireType.Varint).int32(message.stepId);
        /* repeated string input = 7; */
        for (let i = 0; i < message.input.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.input[i]);
        /* repeated string resource = 8; */
        for (let i = 0; i < message.resource.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.resource[i]);
        /* optional string output = 9; */
        if (message.output !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.output);
        /* optional int32 retry = 10; */
        if (message.retry !== undefined)
            writer.tag(10, WireType.Varint).int32(message.retry);
        /* optional bool is_final = 11; */
        if (message.isFinal !== undefined)
            writer.tag(11, WireType.Varint).bool(message.isFinal);
        /* optional bool uses_cache = 12; */
        if (message.usesCache !== undefined)
            writer.tag(12, WireType.Varint).bool(message.usesCache);
        /* optional float download_timeout = 13; */
        if (message.downloadTimeout !== undefined)
            writer.tag(13, WireType.Bit32).float(message.downloadTimeout);
        /* optional float running_timeout = 14; */
        if (message.runningTimeout !== undefined)
            writer.tag(14, WireType.Bit32).float(message.runningTimeout);
        /* optional float upload_timeout = 15; */
        if (message.uploadTimeout !== undefined)
            writer.tag(15, WireType.Bit32).float(message.uploadTimeout);
        /* string status = 16; */
        if (message.status !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.status);
        /* optional int32 worker_id = 17; */
        if (message.workerId !== undefined)
            writer.tag(17, WireType.Varint).int32(message.workerId);
        /* optional int32 workflow_id = 18; */
        if (message.workflowId !== undefined)
            writer.tag(18, WireType.Varint).int32(message.workflowId);
        /* optional string task_name = 19; */
        if (message.taskName !== undefined)
            writer.tag(19, WireType.LengthDelimited).string(message.taskName);
        /* int32 retry_count = 20; */
        if (message.retryCount !== 0)
            writer.tag(20, WireType.Varint).int32(message.retryCount);
        /* bool hidden = 21; */
        if (message.hidden !== false)
            writer.tag(21, WireType.Varint).bool(message.hidden);
        /* optional int32 previous_task_id = 22; */
        if (message.previousTaskId !== undefined)
            writer.tag(22, WireType.Varint).int32(message.previousTaskId);
        /* optional double weight = 23; */
        if (message.weight !== undefined)
            writer.tag(23, WireType.Bit64).double(message.weight);
        /* optional int64 run_start_time = 24; */
        if (message.runStartTime !== undefined)
            writer.tag(24, WireType.Varint).int64(message.runStartTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskList$Type extends MessageType<TaskList> {
    constructor() {
        super("taskqueue.TaskList", [
            { no: 1, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Task }
        ]);
    }
    create(value?: PartialMessage<TaskList>): TaskList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        if (value !== undefined)
            reflectionMergePartial<TaskList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskList): TaskList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskList
 */
export const TaskList = new TaskList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryTaskRequest$Type extends MessageType<RetryTaskRequest> {
    constructor() {
        super("taskqueue.RetryTaskRequest", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "retry", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RetryTaskRequest>): RetryTaskRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        if (value !== undefined)
            reflectionMergePartial<RetryTaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryTaskRequest): RetryTaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* optional int32 retry */ 2:
                    message.retry = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryTaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* optional int32 retry = 2; */
        if (message.retry !== undefined)
            writer.tag(2, WireType.Varint).int32(message.retry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RetryTaskRequest
 */
export const RetryTaskRequest = new RetryTaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Worker$Type extends MessageType<Worker> {
    constructor() {
        super("taskqueue.Worker", [
            { no: 1, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "prefetch", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "ipv4", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ipv6", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "flavor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "step_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "step_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "is_permanent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "recyclable_scope", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "workflow_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "workflow_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Worker>): Worker {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        message.name = "";
        message.concurrency = 0;
        message.prefetch = 0;
        message.status = "";
        message.ipv4 = "";
        message.ipv6 = "";
        message.flavor = "";
        message.provider = "";
        message.region = "";
        message.isPermanent = false;
        message.recyclableScope = "";
        if (value !== undefined)
            reflectionMergePartial<Worker>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Worker): Worker {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 concurrency */ 3:
                    message.concurrency = reader.int32();
                    break;
                case /* int32 prefetch */ 4:
                    message.prefetch = reader.int32();
                    break;
                case /* string status */ 5:
                    message.status = reader.string();
                    break;
                case /* string ipv4 */ 6:
                    message.ipv4 = reader.string();
                    break;
                case /* string ipv6 */ 7:
                    message.ipv6 = reader.string();
                    break;
                case /* string flavor */ 8:
                    message.flavor = reader.string();
                    break;
                case /* string provider */ 9:
                    message.provider = reader.string();
                    break;
                case /* string region */ 10:
                    message.region = reader.string();
                    break;
                case /* optional int32 step_id */ 11:
                    message.stepId = reader.int32();
                    break;
                case /* optional string step_name */ 12:
                    message.stepName = reader.string();
                    break;
                case /* bool is_permanent */ 13:
                    message.isPermanent = reader.bool();
                    break;
                case /* string recyclable_scope */ 14:
                    message.recyclableScope = reader.string();
                    break;
                case /* optional int32 workflow_id */ 15:
                    message.workflowId = reader.int32();
                    break;
                case /* optional string workflow_name */ 16:
                    message.workflowName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Worker, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 concurrency = 3; */
        if (message.concurrency !== 0)
            writer.tag(3, WireType.Varint).int32(message.concurrency);
        /* int32 prefetch = 4; */
        if (message.prefetch !== 0)
            writer.tag(4, WireType.Varint).int32(message.prefetch);
        /* string status = 5; */
        if (message.status !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.status);
        /* string ipv4 = 6; */
        if (message.ipv4 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.ipv4);
        /* string ipv6 = 7; */
        if (message.ipv6 !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ipv6);
        /* string flavor = 8; */
        if (message.flavor !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.flavor);
        /* string provider = 9; */
        if (message.provider !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.provider);
        /* string region = 10; */
        if (message.region !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.region);
        /* optional int32 step_id = 11; */
        if (message.stepId !== undefined)
            writer.tag(11, WireType.Varint).int32(message.stepId);
        /* optional string step_name = 12; */
        if (message.stepName !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.stepName);
        /* bool is_permanent = 13; */
        if (message.isPermanent !== false)
            writer.tag(13, WireType.Varint).bool(message.isPermanent);
        /* string recyclable_scope = 14; */
        if (message.recyclableScope !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.recyclableScope);
        /* optional int32 workflow_id = 15; */
        if (message.workflowId !== undefined)
            writer.tag(15, WireType.Varint).int32(message.workflowId);
        /* optional string workflow_name = 16; */
        if (message.workflowName !== undefined)
            writer.tag(16, WireType.LengthDelimited).string(message.workflowName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Worker
 */
export const Worker = new Worker$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkersList$Type extends MessageType<WorkersList> {
    constructor() {
        super("taskqueue.WorkersList", [
            { no: 1, name: "workers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Worker }
        ]);
    }
    create(value?: PartialMessage<WorkersList>): WorkersList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workers = [];
        if (value !== undefined)
            reflectionMergePartial<WorkersList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkersList): WorkersList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Worker workers */ 1:
                    message.workers.push(Worker.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkersList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Worker workers = 1; */
        for (let i = 0; i < message.workers.length; i++)
            Worker.internalBinaryWrite(message.workers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkersList
 */
export const WorkersList = new WorkersList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWorkersRequest$Type extends MessageType<ListWorkersRequest> {
    constructor() {
        super("taskqueue.ListWorkersRequest", [
            { no: 1, name: "workflow_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListWorkersRequest>): ListWorkersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListWorkersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWorkersRequest): ListWorkersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 workflow_id */ 1:
                    message.workflowId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWorkersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 workflow_id = 1; */
        if (message.workflowId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.workflowId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ListWorkersRequest
 */
export const ListWorkersRequest = new ListWorkersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskUpdate$Type extends MessageType<TaskUpdate> {
    constructor() {
        super("taskqueue.TaskUpdate", [
            { no: 1, name: "weight", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TaskUpdate>): TaskUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.weight = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskUpdate): TaskUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double weight */ 1:
                    message.weight = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double weight = 1; */
        if (message.weight !== 0)
            writer.tag(1, WireType.Bit64).double(message.weight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskUpdate
 */
export const TaskUpdate = new TaskUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskUpdateList$Type extends MessageType<TaskUpdateList> {
    constructor() {
        super("taskqueue.TaskUpdateList", [
            { no: 1, name: "updates", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => TaskUpdate } }
        ]);
    }
    create(value?: PartialMessage<TaskUpdateList>): TaskUpdateList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updates = {};
        if (value !== undefined)
            reflectionMergePartial<TaskUpdateList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskUpdateList): TaskUpdateList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, taskqueue.TaskUpdate> updates */ 1:
                    this.binaryReadMap1(message.updates, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TaskUpdateList["updates"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TaskUpdateList["updates"] | undefined, val: TaskUpdateList["updates"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = TaskUpdate.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for taskqueue.TaskUpdateList.updates");
            }
        }
        map[key ?? 0] = val ?? TaskUpdate.create();
    }
    internalBinaryWrite(message: TaskUpdateList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, taskqueue.TaskUpdate> updates = 1; */
        for (let k of globalThis.Object.keys(message.updates)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            TaskUpdate.internalBinaryWrite(message.updates[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskUpdateList
 */
export const TaskUpdateList = new TaskUpdateList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskListAndOther$Type extends MessageType<TaskListAndOther> {
    constructor() {
        super("taskqueue.TaskListAndOther", [
            { no: 1, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Task },
            { no: 2, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "updates", kind: "message", T: () => TaskUpdateList },
            { no: 4, name: "active_tasks", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskListAndOther>): TaskListAndOther {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tasks = [];
        message.concurrency = 0;
        message.activeTasks = [];
        if (value !== undefined)
            reflectionMergePartial<TaskListAndOther>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskListAndOther): TaskListAndOther {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 concurrency */ 2:
                    message.concurrency = reader.int32();
                    break;
                case /* taskqueue.TaskUpdateList updates */ 3:
                    message.updates = TaskUpdateList.internalBinaryRead(reader, reader.uint32(), options, message.updates);
                    break;
                case /* repeated int32 active_tasks */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.activeTasks.push(reader.int32());
                    else
                        message.activeTasks.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskListAndOther, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 concurrency = 2; */
        if (message.concurrency !== 0)
            writer.tag(2, WireType.Varint).int32(message.concurrency);
        /* taskqueue.TaskUpdateList updates = 3; */
        if (message.updates)
            TaskUpdateList.internalBinaryWrite(message.updates, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 active_tasks = 4; */
        if (message.activeTasks.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.activeTasks.length; i++)
                writer.int32(message.activeTasks[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskListAndOther
 */
export const TaskListAndOther = new TaskListAndOther$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskStatusUpdate$Type extends MessageType<TaskStatusUpdate> {
    constructor() {
        super("taskqueue.TaskStatusUpdate", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "new_status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "duration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "free_retry", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TaskStatusUpdate>): TaskStatusUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.newStatus = "";
        if (value !== undefined)
            reflectionMergePartial<TaskStatusUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskStatusUpdate): TaskStatusUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* string new_status */ 2:
                    message.newStatus = reader.string();
                    break;
                case /* optional int32 duration */ 3:
                    message.duration = reader.int32();
                    break;
                case /* optional bool free_retry */ 4:
                    message.freeRetry = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskStatusUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* string new_status = 2; */
        if (message.newStatus !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newStatus);
        /* optional int32 duration = 3; */
        if (message.duration !== undefined)
            writer.tag(3, WireType.Varint).int32(message.duration);
        /* optional bool free_retry = 4; */
        if (message.freeRetry !== undefined)
            writer.tag(4, WireType.Varint).bool(message.freeRetry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskStatusUpdate
 */
export const TaskStatusUpdate = new TaskStatusUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskLog$Type extends MessageType<TaskLog> {
    constructor() {
        super("taskqueue.TaskLog", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "log_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "log_text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TaskLog>): TaskLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.logType = "";
        message.logText = "";
        if (value !== undefined)
            reflectionMergePartial<TaskLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskLog): TaskLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* string log_type */ 2:
                    message.logType = reader.string();
                    break;
                case /* string log_text */ 3:
                    message.logText = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* string log_type = 2; */
        if (message.logType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.logType);
        /* string log_text = 3; */
        if (message.logText !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.logText);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskLog
 */
export const TaskLog = new TaskLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLogsRequest$Type extends MessageType<GetLogsRequest> {
    constructor() {
        super("taskqueue.GetLogsRequest", [
            { no: 1, name: "taskIds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "chunkSize", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "skipFromEnd", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "log_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetLogsRequest>): GetLogsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskIds = [];
        message.chunkSize = 0;
        if (value !== undefined)
            reflectionMergePartial<GetLogsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLogsRequest): GetLogsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 taskIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.taskIds.push(reader.int32());
                    else
                        message.taskIds.push(reader.int32());
                    break;
                case /* int32 chunkSize */ 2:
                    message.chunkSize = reader.int32();
                    break;
                case /* optional int32 skipFromEnd */ 3:
                    message.skipFromEnd = reader.int32();
                    break;
                case /* optional string log_type */ 4:
                    message.logType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLogsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 taskIds = 1; */
        if (message.taskIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.taskIds.length; i++)
                writer.int32(message.taskIds[i]);
            writer.join();
        }
        /* int32 chunkSize = 2; */
        if (message.chunkSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.chunkSize);
        /* optional int32 skipFromEnd = 3; */
        if (message.skipFromEnd !== undefined)
            writer.tag(3, WireType.Varint).int32(message.skipFromEnd);
        /* optional string log_type = 4; */
        if (message.logType !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.logType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.GetLogsRequest
 */
export const GetLogsRequest = new GetLogsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogChunk$Type extends MessageType<LogChunk> {
    constructor() {
        super("taskqueue.LogChunk", [
            { no: 1, name: "taskId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "stdout", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "stderr", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogChunk>): LogChunk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        message.stdout = [];
        message.stderr = [];
        if (value !== undefined)
            reflectionMergePartial<LogChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogChunk): LogChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 taskId */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* repeated string stdout */ 2:
                    message.stdout.push(reader.string());
                    break;
                case /* repeated string stderr */ 3:
                    message.stderr.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 taskId = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* repeated string stdout = 2; */
        for (let i = 0; i < message.stdout.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.stdout[i]);
        /* repeated string stderr = 3; */
        for (let i = 0; i < message.stderr.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.stderr[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.LogChunk
 */
export const LogChunk = new LogChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogChunkList$Type extends MessageType<LogChunkList> {
    constructor() {
        super("taskqueue.LogChunkList", [
            { no: 1, name: "logs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LogChunk }
        ]);
    }
    create(value?: PartialMessage<LogChunkList>): LogChunkList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.logs = [];
        if (value !== undefined)
            reflectionMergePartial<LogChunkList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogChunkList): LogChunkList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.LogChunk logs */ 1:
                    message.logs.push(LogChunk.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogChunkList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.LogChunk logs = 1; */
        for (let i = 0; i < message.logs.length; i++)
            LogChunk.internalBinaryWrite(message.logs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.LogChunkList
 */
export const LogChunkList = new LogChunkList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskIds$Type extends MessageType<TaskIds> {
    constructor() {
        super("taskqueue.TaskIds", [
            { no: 1, name: "task_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskIds>): TaskIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskIds = [];
        if (value !== undefined)
            reflectionMergePartial<TaskIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskIds): TaskIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 task_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.taskIds.push(reader.int32());
                    else
                        message.taskIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 task_ids = 1; */
        if (message.taskIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.taskIds.length; i++)
                writer.int32(message.taskIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskIds
 */
export const TaskIds = new TaskIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskId$Type extends MessageType<TaskId> {
    constructor() {
        super("taskqueue.TaskId", [
            { no: 1, name: "task_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskId>): TaskId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskId = 0;
        if (value !== undefined)
            reflectionMergePartial<TaskId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskId): TaskId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 task_id */ 1:
                    message.taskId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 task_id = 1; */
        if (message.taskId !== 0)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TaskId
 */
export const TaskId = new TaskId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerId$Type extends MessageType<WorkerId> {
    constructor() {
        super("taskqueue.WorkerId", [
            { no: 1, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerId>): WorkerId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerId): WorkerId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerId
 */
export const WorkerId = new WorkerId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerDeletion$Type extends MessageType<WorkerDeletion> {
    constructor() {
        super("taskqueue.WorkerDeletion", [
            { no: 1, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "undeployed", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerDeletion>): WorkerDeletion {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerDeletion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerDeletion): WorkerDeletion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* optional bool undeployed */ 2:
                    message.undeployed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerDeletion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* optional bool undeployed = 2; */
        if (message.undeployed !== undefined)
            writer.tag(2, WireType.Varint).bool(message.undeployed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerDeletion
 */
export const WorkerDeletion = new WorkerDeletion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerStatusRequest$Type extends MessageType<WorkerStatusRequest> {
    constructor() {
        super("taskqueue.WorkerStatusRequest", [
            { no: 1, name: "worker_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerStatusRequest>): WorkerStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerIds = [];
        if (value !== undefined)
            reflectionMergePartial<WorkerStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerStatusRequest): WorkerStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 worker_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.workerIds.push(reader.int32());
                    else
                        message.workerIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 worker_ids = 1; */
        if (message.workerIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.workerIds.length; i++)
                writer.int32(message.workerIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerStatusRequest
 */
export const WorkerStatusRequest = new WorkerStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerStatus$Type extends MessageType<WorkerStatus> {
    constructor() {
        super("taskqueue.WorkerStatus", [
            { no: 1, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerStatus>): WorkerStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<WorkerStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerStatus): WorkerStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerStatus
 */
export const WorkerStatus = new WorkerStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerStatusResponse$Type extends MessageType<WorkerStatusResponse> {
    constructor() {
        super("taskqueue.WorkerStatusResponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WorkerStatus }
        ]);
    }
    create(value?: PartialMessage<WorkerStatusResponse>): WorkerStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<WorkerStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerStatusResponse): WorkerStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.WorkerStatus statuses */ 1:
                    message.statuses.push(WorkerStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.WorkerStatus statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            WorkerStatus.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerStatusResponse
 */
export const WorkerStatusResponse = new WorkerStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerDetails$Type extends MessageType<WorkerDetails> {
    constructor() {
        super("taskqueue.WorkerDetails", [
            { no: 1, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "worker_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "job_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerDetails>): WorkerDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        message.workerName = "";
        message.jobId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerDetails): WorkerDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* string worker_name */ 2:
                    message.workerName = reader.string();
                    break;
                case /* int32 job_id */ 3:
                    message.jobId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* string worker_name = 2; */
        if (message.workerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workerName);
        /* int32 job_id = 3; */
        if (message.jobId !== 0)
            writer.tag(3, WireType.Varint).int32(message.jobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerDetails
 */
export const WorkerDetails = new WorkerDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerIds$Type extends MessageType<WorkerIds> {
    constructor() {
        super("taskqueue.WorkerIds", [
            { no: 1, name: "workers_details", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WorkerDetails }
        ]);
    }
    create(value?: PartialMessage<WorkerIds>): WorkerIds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workersDetails = [];
        if (value !== undefined)
            reflectionMergePartial<WorkerIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerIds): WorkerIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.WorkerDetails workers_details */ 1:
                    message.workersDetails.push(WorkerDetails.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.WorkerDetails workers_details = 1; */
        for (let i = 0; i < message.workersDetails.length; i++)
            WorkerDetails.internalBinaryWrite(message.workersDetails[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerIds
 */
export const WorkerIds = new WorkerIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PingAndGetNewTasksRequest$Type extends MessageType<PingAndGetNewTasksRequest> {
    constructor() {
        super("taskqueue.PingAndGetNewTasksRequest", [
            { no: 1, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "stats", kind: "message", T: () => WorkerStats }
        ]);
    }
    create(value?: PartialMessage<PingAndGetNewTasksRequest>): PingAndGetNewTasksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        if (value !== undefined)
            reflectionMergePartial<PingAndGetNewTasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingAndGetNewTasksRequest): PingAndGetNewTasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* taskqueue.WorkerStats stats */ 2:
                    message.stats = WorkerStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingAndGetNewTasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* taskqueue.WorkerStats stats = 2; */
        if (message.stats)
            WorkerStats.internalBinaryWrite(message.stats, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.PingAndGetNewTasksRequest
 */
export const PingAndGetNewTasksRequest = new PingAndGetNewTasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ack$Type extends MessageType<Ack> {
    constructor() {
        super("taskqueue.Ack", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Ack>): Ack {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<Ack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ack): Ack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Ack
 */
export const Ack = new Ack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTasksRequest$Type extends MessageType<ListTasksRequest> {
    constructor() {
        super("taskqueue.ListTasksRequest", [
            { no: 1, name: "status_filter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "worker_id_filter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "workflow_id_filter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "step_id_filter", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "command_filter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "offset", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "show_hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ListTasksRequest>): ListTasksRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListTasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTasksRequest): ListTasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string status_filter */ 1:
                    message.statusFilter = reader.string();
                    break;
                case /* optional int32 worker_id_filter */ 2:
                    message.workerIdFilter = reader.int32();
                    break;
                case /* optional int32 workflow_id_filter */ 3:
                    message.workflowIdFilter = reader.int32();
                    break;
                case /* optional int32 step_id_filter */ 4:
                    message.stepIdFilter = reader.int32();
                    break;
                case /* optional string command_filter */ 5:
                    message.commandFilter = reader.string();
                    break;
                case /* optional int32 limit */ 6:
                    message.limit = reader.int32();
                    break;
                case /* optional int32 offset */ 7:
                    message.offset = reader.int32();
                    break;
                case /* optional bool show_hidden */ 8:
                    message.showHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string status_filter = 1; */
        if (message.statusFilter !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.statusFilter);
        /* optional int32 worker_id_filter = 2; */
        if (message.workerIdFilter !== undefined)
            writer.tag(2, WireType.Varint).int32(message.workerIdFilter);
        /* optional int32 workflow_id_filter = 3; */
        if (message.workflowIdFilter !== undefined)
            writer.tag(3, WireType.Varint).int32(message.workflowIdFilter);
        /* optional int32 step_id_filter = 4; */
        if (message.stepIdFilter !== undefined)
            writer.tag(4, WireType.Varint).int32(message.stepIdFilter);
        /* optional string command_filter = 5; */
        if (message.commandFilter !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.commandFilter);
        /* optional int32 limit = 6; */
        if (message.limit !== undefined)
            writer.tag(6, WireType.Varint).int32(message.limit);
        /* optional int32 offset = 7; */
        if (message.offset !== undefined)
            writer.tag(7, WireType.Varint).int32(message.offset);
        /* optional bool show_hidden = 8; */
        if (message.showHidden !== undefined)
            writer.tag(8, WireType.Varint).bool(message.showHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ListTasksRequest
 */
export const ListTasksRequest = new ListTasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerRequest$Type extends MessageType<WorkerRequest> {
    constructor() {
        super("taskqueue.WorkerRequest", [
            { no: 1, name: "provider_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "flavor_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "concurrency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "prefetch", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "step_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerRequest>): WorkerRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerId = 0;
        message.flavorId = 0;
        message.regionId = 0;
        message.number = 0;
        message.concurrency = 0;
        message.prefetch = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerRequest): WorkerRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 provider_id */ 1:
                    message.providerId = reader.int32();
                    break;
                case /* int32 flavor_id */ 2:
                    message.flavorId = reader.int32();
                    break;
                case /* int32 region_id */ 3:
                    message.regionId = reader.int32();
                    break;
                case /* int32 number */ 4:
                    message.number = reader.int32();
                    break;
                case /* int32 concurrency */ 5:
                    message.concurrency = reader.int32();
                    break;
                case /* int32 prefetch */ 6:
                    message.prefetch = reader.int32();
                    break;
                case /* optional int32 step_id */ 7:
                    message.stepId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 provider_id = 1; */
        if (message.providerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.providerId);
        /* int32 flavor_id = 2; */
        if (message.flavorId !== 0)
            writer.tag(2, WireType.Varint).int32(message.flavorId);
        /* int32 region_id = 3; */
        if (message.regionId !== 0)
            writer.tag(3, WireType.Varint).int32(message.regionId);
        /* int32 number = 4; */
        if (message.number !== 0)
            writer.tag(4, WireType.Varint).int32(message.number);
        /* int32 concurrency = 5; */
        if (message.concurrency !== 0)
            writer.tag(5, WireType.Varint).int32(message.concurrency);
        /* int32 prefetch = 6; */
        if (message.prefetch !== 0)
            writer.tag(6, WireType.Varint).int32(message.prefetch);
        /* optional int32 step_id = 7; */
        if (message.stepId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.stepId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerRequest
 */
export const WorkerRequest = new WorkerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerUpdateRequest$Type extends MessageType<WorkerUpdateRequest> {
    constructor() {
        super("taskqueue.WorkerUpdateRequest", [
            { no: 1, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "provider_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "flavor_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "region_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "concurrency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "prefetch", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "step_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "is_permanent", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "recyclable_scope", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerUpdateRequest>): WorkerUpdateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerUpdateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerUpdateRequest): WorkerUpdateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* optional int32 provider_id */ 2:
                    message.providerId = reader.int32();
                    break;
                case /* optional int32 flavor_id */ 3:
                    message.flavorId = reader.int32();
                    break;
                case /* optional int32 region_id */ 4:
                    message.regionId = reader.int32();
                    break;
                case /* optional int32 concurrency */ 5:
                    message.concurrency = reader.int32();
                    break;
                case /* optional int32 prefetch */ 6:
                    message.prefetch = reader.int32();
                    break;
                case /* optional int32 step_id */ 7:
                    message.stepId = reader.int32();
                    break;
                case /* optional bool is_permanent */ 8:
                    message.isPermanent = reader.bool();
                    break;
                case /* optional string recyclable_scope */ 9:
                    message.recyclableScope = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerUpdateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 worker_id = 1; */
        if (message.workerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* optional int32 provider_id = 2; */
        if (message.providerId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.providerId);
        /* optional int32 flavor_id = 3; */
        if (message.flavorId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.flavorId);
        /* optional int32 region_id = 4; */
        if (message.regionId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.regionId);
        /* optional int32 concurrency = 5; */
        if (message.concurrency !== undefined)
            writer.tag(5, WireType.Varint).int32(message.concurrency);
        /* optional int32 prefetch = 6; */
        if (message.prefetch !== undefined)
            writer.tag(6, WireType.Varint).int32(message.prefetch);
        /* optional int32 step_id = 7; */
        if (message.stepId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.stepId);
        /* optional bool is_permanent = 8; */
        if (message.isPermanent !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isPermanent);
        /* optional string recyclable_scope = 9; */
        if (message.recyclableScope !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.recyclableScope);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerUpdateRequest
 */
export const WorkerUpdateRequest = new WorkerUpdateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFlavorsRequest$Type extends MessageType<ListFlavorsRequest> {
    constructor() {
        super("taskqueue.ListFlavorsRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListFlavorsRequest>): ListFlavorsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        message.filter = "";
        if (value !== undefined)
            reflectionMergePartial<ListFlavorsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFlavorsRequest): ListFlavorsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 limit */ 1:
                    message.limit = reader.int32();
                    break;
                case /* string filter */ 2:
                    message.filter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFlavorsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).int32(message.limit);
        /* string filter = 2; */
        if (message.filter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ListFlavorsRequest
 */
export const ListFlavorsRequest = new ListFlavorsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Flavor$Type extends MessageType<Flavor> {
    constructor() {
        super("taskqueue.Flavor", [
            { no: 1, name: "flavor_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "flavor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "provider_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "cpu", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "mem", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "disk", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "bandwidth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "gpu", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "gpumem", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "has_gpu", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "has_quick_disks", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "eviction", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 16, name: "cost", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Flavor>): Flavor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flavorId = 0;
        message.flavorName = "";
        message.providerId = 0;
        message.provider = "";
        message.cpu = 0;
        message.mem = 0;
        message.disk = 0;
        message.bandwidth = 0;
        message.gpu = "";
        message.gpumem = 0;
        message.hasGpu = false;
        message.hasQuickDisks = false;
        message.regionId = 0;
        message.region = "";
        message.eviction = 0;
        message.cost = 0;
        if (value !== undefined)
            reflectionMergePartial<Flavor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Flavor): Flavor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 flavor_id */ 1:
                    message.flavorId = reader.int32();
                    break;
                case /* string flavor_name */ 2:
                    message.flavorName = reader.string();
                    break;
                case /* int32 provider_id */ 3:
                    message.providerId = reader.int32();
                    break;
                case /* string provider */ 4:
                    message.provider = reader.string();
                    break;
                case /* int32 cpu */ 5:
                    message.cpu = reader.int32();
                    break;
                case /* float mem */ 6:
                    message.mem = reader.float();
                    break;
                case /* float disk */ 7:
                    message.disk = reader.float();
                    break;
                case /* int32 bandwidth */ 8:
                    message.bandwidth = reader.int32();
                    break;
                case /* string gpu */ 9:
                    message.gpu = reader.string();
                    break;
                case /* int32 gpumem */ 10:
                    message.gpumem = reader.int32();
                    break;
                case /* bool has_gpu */ 11:
                    message.hasGpu = reader.bool();
                    break;
                case /* bool has_quick_disks */ 12:
                    message.hasQuickDisks = reader.bool();
                    break;
                case /* int32 region_id */ 13:
                    message.regionId = reader.int32();
                    break;
                case /* string region */ 14:
                    message.region = reader.string();
                    break;
                case /* float eviction */ 15:
                    message.eviction = reader.float();
                    break;
                case /* float cost */ 16:
                    message.cost = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Flavor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 flavor_id = 1; */
        if (message.flavorId !== 0)
            writer.tag(1, WireType.Varint).int32(message.flavorId);
        /* string flavor_name = 2; */
        if (message.flavorName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.flavorName);
        /* int32 provider_id = 3; */
        if (message.providerId !== 0)
            writer.tag(3, WireType.Varint).int32(message.providerId);
        /* string provider = 4; */
        if (message.provider !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.provider);
        /* int32 cpu = 5; */
        if (message.cpu !== 0)
            writer.tag(5, WireType.Varint).int32(message.cpu);
        /* float mem = 6; */
        if (message.mem !== 0)
            writer.tag(6, WireType.Bit32).float(message.mem);
        /* float disk = 7; */
        if (message.disk !== 0)
            writer.tag(7, WireType.Bit32).float(message.disk);
        /* int32 bandwidth = 8; */
        if (message.bandwidth !== 0)
            writer.tag(8, WireType.Varint).int32(message.bandwidth);
        /* string gpu = 9; */
        if (message.gpu !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.gpu);
        /* int32 gpumem = 10; */
        if (message.gpumem !== 0)
            writer.tag(10, WireType.Varint).int32(message.gpumem);
        /* bool has_gpu = 11; */
        if (message.hasGpu !== false)
            writer.tag(11, WireType.Varint).bool(message.hasGpu);
        /* bool has_quick_disks = 12; */
        if (message.hasQuickDisks !== false)
            writer.tag(12, WireType.Varint).bool(message.hasQuickDisks);
        /* int32 region_id = 13; */
        if (message.regionId !== 0)
            writer.tag(13, WireType.Varint).int32(message.regionId);
        /* string region = 14; */
        if (message.region !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.region);
        /* float eviction = 15; */
        if (message.eviction !== 0)
            writer.tag(15, WireType.Bit32).float(message.eviction);
        /* float cost = 16; */
        if (message.cost !== 0)
            writer.tag(16, WireType.Bit32).float(message.cost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Flavor
 */
export const Flavor = new Flavor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlavorsList$Type extends MessageType<FlavorsList> {
    constructor() {
        super("taskqueue.FlavorsList", [
            { no: 1, name: "flavors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Flavor }
        ]);
    }
    create(value?: PartialMessage<FlavorsList>): FlavorsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flavors = [];
        if (value !== undefined)
            reflectionMergePartial<FlavorsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlavorsList): FlavorsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Flavor flavors */ 1:
                    message.flavors.push(Flavor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlavorsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Flavor flavors = 1; */
        for (let i = 0; i < message.flavors.length; i++)
            Flavor.internalBinaryWrite(message.flavors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.FlavorsList
 */
export const FlavorsList = new FlavorsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListJobsRequest$Type extends MessageType<ListJobsRequest> {
    constructor() {
        super("taskqueue.ListJobsRequest", [
            { no: 1, name: "limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "offset", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListJobsRequest>): ListJobsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListJobsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListJobsRequest): ListJobsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 limit */ 1:
                    message.limit = reader.int32();
                    break;
                case /* optional int32 offset */ 2:
                    message.offset = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListJobsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 limit = 1; */
        if (message.limit !== undefined)
            writer.tag(1, WireType.Varint).int32(message.limit);
        /* optional int32 offset = 2; */
        if (message.offset !== undefined)
            writer.tag(2, WireType.Varint).int32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ListJobsRequest
 */
export const ListJobsRequest = new ListJobsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Job$Type extends MessageType<Job> {
    constructor() {
        super("taskqueue.Job", [
            { no: 1, name: "job_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "flavor_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "retry", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "worker_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "action", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "modified_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "progression", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Job>): Job {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0;
        message.status = "";
        message.flavorId = 0;
        message.retry = 0;
        message.workerId = 0;
        message.action = "";
        message.createdAt = "";
        message.modifiedAt = "";
        message.progression = 0;
        message.log = "";
        if (value !== undefined)
            reflectionMergePartial<Job>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Job): Job {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 job_id */ 1:
                    message.jobId = reader.int32();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* int32 flavor_id */ 3:
                    message.flavorId = reader.int32();
                    break;
                case /* int32 retry */ 4:
                    message.retry = reader.int32();
                    break;
                case /* int32 worker_id */ 5:
                    message.workerId = reader.int32();
                    break;
                case /* string action */ 6:
                    message.action = reader.string();
                    break;
                case /* string created_at */ 7:
                    message.createdAt = reader.string();
                    break;
                case /* string modified_at */ 8:
                    message.modifiedAt = reader.string();
                    break;
                case /* int32 progression */ 9:
                    message.progression = reader.int32();
                    break;
                case /* string log */ 10:
                    message.log = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Job, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 job_id = 1; */
        if (message.jobId !== 0)
            writer.tag(1, WireType.Varint).int32(message.jobId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* int32 flavor_id = 3; */
        if (message.flavorId !== 0)
            writer.tag(3, WireType.Varint).int32(message.flavorId);
        /* int32 retry = 4; */
        if (message.retry !== 0)
            writer.tag(4, WireType.Varint).int32(message.retry);
        /* int32 worker_id = 5; */
        if (message.workerId !== 0)
            writer.tag(5, WireType.Varint).int32(message.workerId);
        /* string action = 6; */
        if (message.action !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.action);
        /* string created_at = 7; */
        if (message.createdAt !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.createdAt);
        /* string modified_at = 8; */
        if (message.modifiedAt !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.modifiedAt);
        /* int32 progression = 9; */
        if (message.progression !== 0)
            writer.tag(9, WireType.Varint).int32(message.progression);
        /* string log = 10; */
        if (message.log !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.log);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Job
 */
export const Job = new Job$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobId$Type extends MessageType<JobId> {
    constructor() {
        super("taskqueue.JobId", [
            { no: 1, name: "job_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<JobId>): JobId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0;
        if (value !== undefined)
            reflectionMergePartial<JobId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobId): JobId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 job_id */ 1:
                    message.jobId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 job_id = 1; */
        if (message.jobId !== 0)
            writer.tag(1, WireType.Varint).int32(message.jobId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.JobId
 */
export const JobId = new JobId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobsList$Type extends MessageType<JobsList> {
    constructor() {
        super("taskqueue.JobsList", [
            { no: 1, name: "jobs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Job }
        ]);
    }
    create(value?: PartialMessage<JobsList>): JobsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobs = [];
        if (value !== undefined)
            reflectionMergePartial<JobsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobsList): JobsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Job jobs */ 1:
                    message.jobs.push(Job.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Job jobs = 1; */
        for (let i = 0; i < message.jobs.length; i++)
            Job.internalBinaryWrite(message.jobs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.JobsList
 */
export const JobsList = new JobsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobStatusRequest$Type extends MessageType<JobStatusRequest> {
    constructor() {
        super("taskqueue.JobStatusRequest", [
            { no: 1, name: "job_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<JobStatusRequest>): JobStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobIds = [];
        if (value !== undefined)
            reflectionMergePartial<JobStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobStatusRequest): JobStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 job_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.jobIds.push(reader.int32());
                    else
                        message.jobIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 job_ids = 1; */
        if (message.jobIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.jobIds.length; i++)
                writer.int32(message.jobIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.JobStatusRequest
 */
export const JobStatusRequest = new JobStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobStatus$Type extends MessageType<JobStatus> {
    constructor() {
        super("taskqueue.JobStatus", [
            { no: 1, name: "job_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "progression", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<JobStatus>): JobStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0;
        message.status = "";
        message.progression = 0;
        if (value !== undefined)
            reflectionMergePartial<JobStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobStatus): JobStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 job_id */ 1:
                    message.jobId = reader.int32();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                case /* int32 progression */ 3:
                    message.progression = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 job_id = 1; */
        if (message.jobId !== 0)
            writer.tag(1, WireType.Varint).int32(message.jobId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* int32 progression = 3; */
        if (message.progression !== 0)
            writer.tag(3, WireType.Varint).int32(message.progression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.JobStatus
 */
export const JobStatus = new JobStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobStatusResponse$Type extends MessageType<JobStatusResponse> {
    constructor() {
        super("taskqueue.JobStatusResponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => JobStatus }
        ]);
    }
    create(value?: PartialMessage<JobStatusResponse>): JobStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<JobStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobStatusResponse): JobStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.JobStatus statuses */ 1:
                    message.statuses.push(JobStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.JobStatus statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            JobStatus.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.JobStatusResponse
 */
export const JobStatusResponse = new JobStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JobUpdate$Type extends MessageType<JobUpdate> {
    constructor() {
        super("taskqueue.JobUpdate", [
            { no: 1, name: "job_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "append_log", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "progression", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<JobUpdate>): JobUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.jobId = 0;
        if (value !== undefined)
            reflectionMergePartial<JobUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JobUpdate): JobUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 job_id */ 1:
                    message.jobId = reader.int32();
                    break;
                case /* optional string status */ 2:
                    message.status = reader.string();
                    break;
                case /* optional string append_log */ 3:
                    message.appendLog = reader.string();
                    break;
                case /* optional int32 progression */ 4:
                    message.progression = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JobUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 job_id = 1; */
        if (message.jobId !== 0)
            writer.tag(1, WireType.Varint).int32(message.jobId);
        /* optional string status = 2; */
        if (message.status !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        /* optional string append_log = 3; */
        if (message.appendLog !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.appendLog);
        /* optional int32 progression = 4; */
        if (message.progression !== undefined)
            writer.tag(4, WireType.Varint).int32(message.progression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.JobUpdate
 */
export const JobUpdate = new JobUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RcloneRemotes$Type extends MessageType<RcloneRemotes> {
    constructor() {
        super("taskqueue.RcloneRemotes", [
            { no: 1, name: "remotes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => RcloneRemote } }
        ]);
    }
    create(value?: PartialMessage<RcloneRemotes>): RcloneRemotes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.remotes = {};
        if (value !== undefined)
            reflectionMergePartial<RcloneRemotes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RcloneRemotes): RcloneRemotes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, taskqueue.RcloneRemote> remotes */ 1:
                    this.binaryReadMap1(message.remotes, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: RcloneRemotes["remotes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RcloneRemotes["remotes"] | undefined, val: RcloneRemotes["remotes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = RcloneRemote.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for taskqueue.RcloneRemotes.remotes");
            }
        }
        map[key ?? ""] = val ?? RcloneRemote.create();
    }
    internalBinaryWrite(message: RcloneRemotes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, taskqueue.RcloneRemote> remotes = 1; */
        for (let k of globalThis.Object.keys(message.remotes)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            RcloneRemote.internalBinaryWrite(message.remotes[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RcloneRemotes
 */
export const RcloneRemotes = new RcloneRemotes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RcloneRemote$Type extends MessageType<RcloneRemote> {
    constructor() {
        super("taskqueue.RcloneRemote", [
            { no: 1, name: "options", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<RcloneRemote>): RcloneRemote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.options = {};
        if (value !== undefined)
            reflectionMergePartial<RcloneRemote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RcloneRemote): RcloneRemote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> options */ 1:
                    this.binaryReadMap1(message.options, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: RcloneRemote["options"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RcloneRemote["options"] | undefined, val: RcloneRemote["options"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for taskqueue.RcloneRemote.options");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: RcloneRemote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> options = 1; */
        for (let k of globalThis.Object.keys(message.options))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.options[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RcloneRemote
 */
export const RcloneRemote = new RcloneRemote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DockerCredential$Type extends MessageType<DockerCredential> {
    constructor() {
        super("taskqueue.DockerCredential", [
            { no: 1, name: "registry", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "auth", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DockerCredential>): DockerCredential {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.registry = "";
        message.auth = "";
        if (value !== undefined)
            reflectionMergePartial<DockerCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DockerCredential): DockerCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string registry */ 1:
                    message.registry = reader.string();
                    break;
                case /* string auth */ 2:
                    message.auth = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DockerCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string registry = 1; */
        if (message.registry !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.registry);
        /* string auth = 2; */
        if (message.auth !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.auth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.DockerCredential
 */
export const DockerCredential = new DockerCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DockerCredentials$Type extends MessageType<DockerCredentials> {
    constructor() {
        super("taskqueue.DockerCredentials", [
            { no: 1, name: "credentials", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DockerCredential }
        ]);
    }
    create(value?: PartialMessage<DockerCredentials>): DockerCredentials {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentials = [];
        if (value !== undefined)
            reflectionMergePartial<DockerCredentials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DockerCredentials): DockerCredentials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.DockerCredential credentials */ 1:
                    message.credentials.push(DockerCredential.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DockerCredentials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.DockerCredential credentials = 1; */
        for (let i = 0; i < message.credentials.length; i++)
            DockerCredential.internalBinaryWrite(message.credentials[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.DockerCredentials
 */
export const DockerCredentials = new DockerCredentials$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("taskqueue.LoginRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("taskqueue.LoginResponse", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token$Type extends MessageType<Token> {
    constructor() {
        super("taskqueue.Token", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Token>): Token {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<Token>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token): Token {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Token
 */
export const Token = new Token$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateUserRequest$Type extends MessageType<CreateUserRequest> {
    constructor() {
        super("taskqueue.CreateUserRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_admin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CreateUserRequest>): CreateUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        message.email = "";
        message.isAdmin = false;
        if (value !== undefined)
            reflectionMergePartial<CreateUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateUserRequest): CreateUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* bool is_admin */ 4:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* bool is_admin = 4; */
        if (message.isAdmin !== false)
            writer.tag(4, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.CreateUserRequest
 */
export const CreateUserRequest = new CreateUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserId$Type extends MessageType<UserId> {
    constructor() {
        super("taskqueue.UserId", [
            { no: 1, name: "user_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UserId>): UserId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0;
        if (value !== undefined)
            reflectionMergePartial<UserId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserId): UserId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 user_id */ 1:
                    message.userId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 user_id = 1; */
        if (message.userId !== 0)
            writer.tag(1, WireType.Varint).int32(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.UserId
 */
export const UserId = new UserId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("taskqueue.User", [
            { no: 1, name: "user_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "email", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_admin", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = 0;
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 user_id */ 1:
                    message.userId = reader.int32();
                    break;
                case /* optional string username */ 2:
                    message.username = reader.string();
                    break;
                case /* optional string email */ 3:
                    message.email = reader.string();
                    break;
                case /* optional bool is_admin */ 4:
                    message.isAdmin = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 user_id = 1; */
        if (message.userId !== 0)
            writer.tag(1, WireType.Varint).int32(message.userId);
        /* optional string username = 2; */
        if (message.username !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* optional string email = 3; */
        if (message.email !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* optional bool is_admin = 4; */
        if (message.isAdmin !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isAdmin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UsersList$Type extends MessageType<UsersList> {
    constructor() {
        super("taskqueue.UsersList", [
            { no: 1, name: "users", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => User }
        ]);
    }
    create(value?: PartialMessage<UsersList>): UsersList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial<UsersList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UsersList): UsersList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.User users */ 1:
                    message.users.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UsersList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.User users = 1; */
        for (let i = 0; i < message.users.length; i++)
            User.internalBinaryWrite(message.users[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.UsersList
 */
export const UsersList = new UsersList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordRequest$Type extends MessageType<ChangePasswordRequest> {
    constructor() {
        super("taskqueue.ChangePasswordRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "old_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordRequest>): ChangePasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.oldPassword = "";
        message.newPassword = "";
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordRequest): ChangePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string old_password */ 2:
                    message.oldPassword = reader.string();
                    break;
                case /* string new_password */ 3:
                    message.newPassword = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string old_password = 2; */
        if (message.oldPassword !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.oldPassword);
        /* string new_password = 3; */
        if (message.newPassword !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newPassword);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ChangePasswordRequest
 */
export const ChangePasswordRequest = new ChangePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecruiterFilter$Type extends MessageType<RecruiterFilter> {
    constructor() {
        super("taskqueue.RecruiterFilter", [
            { no: 1, name: "step_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RecruiterFilter>): RecruiterFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RecruiterFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecruiterFilter): RecruiterFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 step_id */ 1:
                    message.stepId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecruiterFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 step_id = 1; */
        if (message.stepId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.stepId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RecruiterFilter
 */
export const RecruiterFilter = new RecruiterFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecruiterId$Type extends MessageType<RecruiterId> {
    constructor() {
        super("taskqueue.RecruiterId", [
            { no: 1, name: "step_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RecruiterId>): RecruiterId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepId = 0;
        message.rank = 0;
        if (value !== undefined)
            reflectionMergePartial<RecruiterId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecruiterId): RecruiterId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 step_id */ 1:
                    message.stepId = reader.int32();
                    break;
                case /* int32 rank */ 2:
                    message.rank = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecruiterId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 step_id = 1; */
        if (message.stepId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stepId);
        /* int32 rank = 2; */
        if (message.rank !== 0)
            writer.tag(2, WireType.Varint).int32(message.rank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RecruiterId
 */
export const RecruiterId = new RecruiterId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Recruiter$Type extends MessageType<Recruiter> {
    constructor() {
        super("taskqueue.Recruiter", [
            { no: 1, name: "step_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "protofilter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "concurrency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "prefetch", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "max_workers", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "rounds", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "timeout", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "cpu_per_task", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "memory_per_task", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "disk_per_task", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "prefetch_percent", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "concurrency_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "concurrency_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Recruiter>): Recruiter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepId = 0;
        message.rank = 0;
        message.protofilter = "";
        message.rounds = 0;
        message.timeout = 0;
        if (value !== undefined)
            reflectionMergePartial<Recruiter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Recruiter): Recruiter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 step_id */ 1:
                    message.stepId = reader.int32();
                    break;
                case /* int32 rank */ 2:
                    message.rank = reader.int32();
                    break;
                case /* string protofilter */ 3:
                    message.protofilter = reader.string();
                    break;
                case /* optional int32 concurrency */ 4:
                    message.concurrency = reader.int32();
                    break;
                case /* optional int32 prefetch */ 5:
                    message.prefetch = reader.int32();
                    break;
                case /* optional int32 max_workers */ 6:
                    message.maxWorkers = reader.int32();
                    break;
                case /* int32 rounds */ 7:
                    message.rounds = reader.int32();
                    break;
                case /* int32 timeout */ 8:
                    message.timeout = reader.int32();
                    break;
                case /* optional int32 cpu_per_task */ 9:
                    message.cpuPerTask = reader.int32();
                    break;
                case /* optional float memory_per_task */ 10:
                    message.memoryPerTask = reader.float();
                    break;
                case /* optional float disk_per_task */ 11:
                    message.diskPerTask = reader.float();
                    break;
                case /* optional int32 prefetch_percent */ 12:
                    message.prefetchPercent = reader.int32();
                    break;
                case /* optional int32 concurrency_min */ 13:
                    message.concurrencyMin = reader.int32();
                    break;
                case /* optional int32 concurrency_max */ 14:
                    message.concurrencyMax = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Recruiter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 step_id = 1; */
        if (message.stepId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stepId);
        /* int32 rank = 2; */
        if (message.rank !== 0)
            writer.tag(2, WireType.Varint).int32(message.rank);
        /* string protofilter = 3; */
        if (message.protofilter !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.protofilter);
        /* optional int32 concurrency = 4; */
        if (message.concurrency !== undefined)
            writer.tag(4, WireType.Varint).int32(message.concurrency);
        /* optional int32 prefetch = 5; */
        if (message.prefetch !== undefined)
            writer.tag(5, WireType.Varint).int32(message.prefetch);
        /* optional int32 max_workers = 6; */
        if (message.maxWorkers !== undefined)
            writer.tag(6, WireType.Varint).int32(message.maxWorkers);
        /* int32 rounds = 7; */
        if (message.rounds !== 0)
            writer.tag(7, WireType.Varint).int32(message.rounds);
        /* int32 timeout = 8; */
        if (message.timeout !== 0)
            writer.tag(8, WireType.Varint).int32(message.timeout);
        /* optional int32 cpu_per_task = 9; */
        if (message.cpuPerTask !== undefined)
            writer.tag(9, WireType.Varint).int32(message.cpuPerTask);
        /* optional float memory_per_task = 10; */
        if (message.memoryPerTask !== undefined)
            writer.tag(10, WireType.Bit32).float(message.memoryPerTask);
        /* optional float disk_per_task = 11; */
        if (message.diskPerTask !== undefined)
            writer.tag(11, WireType.Bit32).float(message.diskPerTask);
        /* optional int32 prefetch_percent = 12; */
        if (message.prefetchPercent !== undefined)
            writer.tag(12, WireType.Varint).int32(message.prefetchPercent);
        /* optional int32 concurrency_min = 13; */
        if (message.concurrencyMin !== undefined)
            writer.tag(13, WireType.Varint).int32(message.concurrencyMin);
        /* optional int32 concurrency_max = 14; */
        if (message.concurrencyMax !== undefined)
            writer.tag(14, WireType.Varint).int32(message.concurrencyMax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Recruiter
 */
export const Recruiter = new Recruiter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecruiterUpdate$Type extends MessageType<RecruiterUpdate> {
    constructor() {
        super("taskqueue.RecruiterUpdate", [
            { no: 1, name: "step_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rank", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "protofilter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "concurrency", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "prefetch", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "max_workers", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "rounds", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "timeout", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "cpu_per_task", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "memory_per_task", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "disk_per_task", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "prefetch_percent", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "concurrency_min", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "concurrency_max", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RecruiterUpdate>): RecruiterUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepId = 0;
        message.rank = 0;
        if (value !== undefined)
            reflectionMergePartial<RecruiterUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecruiterUpdate): RecruiterUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 step_id */ 1:
                    message.stepId = reader.int32();
                    break;
                case /* int32 rank */ 2:
                    message.rank = reader.int32();
                    break;
                case /* optional string protofilter */ 3:
                    message.protofilter = reader.string();
                    break;
                case /* optional int32 concurrency */ 4:
                    message.concurrency = reader.int32();
                    break;
                case /* optional int32 prefetch */ 5:
                    message.prefetch = reader.int32();
                    break;
                case /* optional int32 max_workers */ 6:
                    message.maxWorkers = reader.int32();
                    break;
                case /* optional int32 rounds */ 7:
                    message.rounds = reader.int32();
                    break;
                case /* optional int32 timeout */ 8:
                    message.timeout = reader.int32();
                    break;
                case /* optional int32 cpu_per_task */ 9:
                    message.cpuPerTask = reader.int32();
                    break;
                case /* optional float memory_per_task */ 10:
                    message.memoryPerTask = reader.float();
                    break;
                case /* optional float disk_per_task */ 11:
                    message.diskPerTask = reader.float();
                    break;
                case /* optional int32 prefetch_percent */ 12:
                    message.prefetchPercent = reader.int32();
                    break;
                case /* optional int32 concurrency_min */ 13:
                    message.concurrencyMin = reader.int32();
                    break;
                case /* optional int32 concurrency_max */ 14:
                    message.concurrencyMax = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecruiterUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 step_id = 1; */
        if (message.stepId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stepId);
        /* int32 rank = 2; */
        if (message.rank !== 0)
            writer.tag(2, WireType.Varint).int32(message.rank);
        /* optional string protofilter = 3; */
        if (message.protofilter !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.protofilter);
        /* optional int32 concurrency = 4; */
        if (message.concurrency !== undefined)
            writer.tag(4, WireType.Varint).int32(message.concurrency);
        /* optional int32 prefetch = 5; */
        if (message.prefetch !== undefined)
            writer.tag(5, WireType.Varint).int32(message.prefetch);
        /* optional int32 max_workers = 6; */
        if (message.maxWorkers !== undefined)
            writer.tag(6, WireType.Varint).int32(message.maxWorkers);
        /* optional int32 rounds = 7; */
        if (message.rounds !== undefined)
            writer.tag(7, WireType.Varint).int32(message.rounds);
        /* optional int32 timeout = 8; */
        if (message.timeout !== undefined)
            writer.tag(8, WireType.Varint).int32(message.timeout);
        /* optional int32 cpu_per_task = 9; */
        if (message.cpuPerTask !== undefined)
            writer.tag(9, WireType.Varint).int32(message.cpuPerTask);
        /* optional float memory_per_task = 10; */
        if (message.memoryPerTask !== undefined)
            writer.tag(10, WireType.Bit32).float(message.memoryPerTask);
        /* optional float disk_per_task = 11; */
        if (message.diskPerTask !== undefined)
            writer.tag(11, WireType.Bit32).float(message.diskPerTask);
        /* optional int32 prefetch_percent = 12; */
        if (message.prefetchPercent !== undefined)
            writer.tag(12, WireType.Varint).int32(message.prefetchPercent);
        /* optional int32 concurrency_min = 13; */
        if (message.concurrencyMin !== undefined)
            writer.tag(13, WireType.Varint).int32(message.concurrencyMin);
        /* optional int32 concurrency_max = 14; */
        if (message.concurrencyMax !== undefined)
            writer.tag(14, WireType.Varint).int32(message.concurrencyMax);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RecruiterUpdate
 */
export const RecruiterUpdate = new RecruiterUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecruiterList$Type extends MessageType<RecruiterList> {
    constructor() {
        super("taskqueue.RecruiterList", [
            { no: 1, name: "recruiters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Recruiter }
        ]);
    }
    create(value?: PartialMessage<RecruiterList>): RecruiterList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recruiters = [];
        if (value !== undefined)
            reflectionMergePartial<RecruiterList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecruiterList): RecruiterList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Recruiter recruiters */ 1:
                    message.recruiters.push(Recruiter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecruiterList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Recruiter recruiters = 1; */
        for (let i = 0; i < message.recruiters.length; i++)
            Recruiter.internalBinaryWrite(message.recruiters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RecruiterList
 */
export const RecruiterList = new RecruiterList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowFilter$Type extends MessageType<WorkflowFilter> {
    constructor() {
        super("taskqueue.WorkflowFilter", [
            { no: 1, name: "name_like", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "offset", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowFilter>): WorkflowFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkflowFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowFilter): WorkflowFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string name_like */ 1:
                    message.nameLike = reader.string();
                    break;
                case /* optional int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* optional int32 offset */ 3:
                    message.offset = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string name_like = 1; */
        if (message.nameLike !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.nameLike);
        /* optional int32 limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* optional int32 offset = 3; */
        if (message.offset !== undefined)
            writer.tag(3, WireType.Varint).int32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkflowFilter
 */
export const WorkflowFilter = new WorkflowFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowId$Type extends MessageType<WorkflowId> {
    constructor() {
        super("taskqueue.WorkflowId", [
            { no: 1, name: "workflow_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowId>): WorkflowId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflowId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkflowId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowId): WorkflowId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 workflow_id */ 1:
                    message.workflowId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 workflow_id = 1; */
        if (message.workflowId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workflowId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkflowId
 */
export const WorkflowId = new WorkflowId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Workflow$Type extends MessageType<Workflow> {
    constructor() {
        super("taskqueue.Workflow", [
            { no: 1, name: "workflow_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "run_strategy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "maximum_workers", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Workflow>): Workflow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflowId = 0;
        message.name = "";
        message.runStrategy = "";
        if (value !== undefined)
            reflectionMergePartial<Workflow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Workflow): Workflow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 workflow_id */ 1:
                    message.workflowId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string run_strategy */ 4:
                    message.runStrategy = reader.string();
                    break;
                case /* optional int32 maximum_workers */ 5:
                    message.maximumWorkers = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Workflow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 workflow_id = 1; */
        if (message.workflowId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workflowId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string run_strategy = 4; */
        if (message.runStrategy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.runStrategy);
        /* optional int32 maximum_workers = 5; */
        if (message.maximumWorkers !== undefined)
            writer.tag(5, WireType.Varint).int32(message.maximumWorkers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Workflow
 */
export const Workflow = new Workflow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowRequest$Type extends MessageType<WorkflowRequest> {
    constructor() {
        super("taskqueue.WorkflowRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "run_strategy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "maximum_workers", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkflowRequest>): WorkflowRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WorkflowRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowRequest): WorkflowRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string run_strategy */ 2:
                    message.runStrategy = reader.string();
                    break;
                case /* optional int32 maximum_workers */ 3:
                    message.maximumWorkers = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string run_strategy = 2; */
        if (message.runStrategy !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.runStrategy);
        /* optional int32 maximum_workers = 3; */
        if (message.maximumWorkers !== undefined)
            writer.tag(3, WireType.Varint).int32(message.maximumWorkers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkflowRequest
 */
export const WorkflowRequest = new WorkflowRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkflowList$Type extends MessageType<WorkflowList> {
    constructor() {
        super("taskqueue.WorkflowList", [
            { no: 1, name: "workflows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Workflow }
        ]);
    }
    create(value?: PartialMessage<WorkflowList>): WorkflowList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflows = [];
        if (value !== undefined)
            reflectionMergePartial<WorkflowList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkflowList): WorkflowList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Workflow workflows */ 1:
                    message.workflows.push(Workflow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkflowList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Workflow workflows = 1; */
        for (let i = 0; i < message.workflows.length; i++)
            Workflow.internalBinaryWrite(message.workflows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkflowList
 */
export const WorkflowList = new WorkflowList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepFilter$Type extends MessageType<StepFilter> {
    constructor() {
        super("taskqueue.StepFilter", [
            { no: 1, name: "WorkflowId", kind: "scalar", jsonName: "WorkflowId", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "offset", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StepFilter>): StepFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflowId = 0;
        if (value !== undefined)
            reflectionMergePartial<StepFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepFilter): StepFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 WorkflowId */ 1:
                    message.workflowId = reader.int32();
                    break;
                case /* optional int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* optional int32 offset */ 3:
                    message.offset = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 WorkflowId = 1; */
        if (message.workflowId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workflowId);
        /* optional int32 limit = 2; */
        if (message.limit !== undefined)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* optional int32 offset = 3; */
        if (message.offset !== undefined)
            writer.tag(3, WireType.Varint).int32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.StepFilter
 */
export const StepFilter = new StepFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepId$Type extends MessageType<StepId> {
    constructor() {
        super("taskqueue.StepId", [
            { no: 1, name: "step_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StepId>): StepId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepId = 0;
        if (value !== undefined)
            reflectionMergePartial<StepId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepId): StepId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 step_id */ 1:
                    message.stepId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 step_id = 1; */
        if (message.stepId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stepId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.StepId
 */
export const StepId = new StepId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Step$Type extends MessageType<Step> {
    constructor() {
        super("taskqueue.Step", [
            { no: 1, name: "step_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "workflow_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "workflow_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Step>): Step {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepId = 0;
        message.workflowName = "";
        message.workflowId = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Step>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Step): Step {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 step_id */ 1:
                    message.stepId = reader.int32();
                    break;
                case /* string workflow_name */ 2:
                    message.workflowName = reader.string();
                    break;
                case /* int32 workflow_id */ 3:
                    message.workflowId = reader.int32();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Step, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 step_id = 1; */
        if (message.stepId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stepId);
        /* string workflow_name = 2; */
        if (message.workflowName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workflowName);
        /* int32 workflow_id = 3; */
        if (message.workflowId !== 0)
            writer.tag(3, WireType.Varint).int32(message.workflowId);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Step
 */
export const Step = new Step$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepRequest$Type extends MessageType<StepRequest> {
    constructor() {
        super("taskqueue.StepRequest", [
            { no: 1, name: "workflow_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "workflow_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StepRequest>): StepRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<StepRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepRequest): StepRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string workflow_name */ 1:
                    message.workflowName = reader.string();
                    break;
                case /* optional int32 workflow_id */ 2:
                    message.workflowId = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string workflow_name = 1; */
        if (message.workflowName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.workflowName);
        /* optional int32 workflow_id = 2; */
        if (message.workflowId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.workflowId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.StepRequest
 */
export const StepRequest = new StepRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepList$Type extends MessageType<StepList> {
    constructor() {
        super("taskqueue.StepList", [
            { no: 1, name: "steps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Step }
        ]);
    }
    create(value?: PartialMessage<StepList>): StepList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.steps = [];
        if (value !== undefined)
            reflectionMergePartial<StepList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepList): StepList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Step steps */ 1:
                    message.steps.push(Step.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Step steps = 1; */
        for (let i = 0; i < message.steps.length; i++)
            Step.internalBinaryWrite(message.steps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.StepList
 */
export const StepList = new StepList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepStatsRequest$Type extends MessageType<StepStatsRequest> {
    constructor() {
        super("taskqueue.StepStatsRequest", [
            { no: 1, name: "workflow_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "step_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StepStatsRequest>): StepStatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepIds = [];
        if (value !== undefined)
            reflectionMergePartial<StepStatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepStatsRequest): StepStatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 workflow_id */ 1:
                    message.workflowId = reader.int32();
                    break;
                case /* repeated int32 step_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.stepIds.push(reader.int32());
                    else
                        message.stepIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepStatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 workflow_id = 1; */
        if (message.workflowId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.workflowId);
        /* repeated int32 step_ids = 2; */
        if (message.stepIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.stepIds.length; i++)
                writer.int32(message.stepIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.StepStatsRequest
 */
export const StepStatsRequest = new StepStatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Accum$Type extends MessageType<Accum> {
    constructor() {
        super("taskqueue.Accum", [
            { no: 1, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sum", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "min", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "max", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Accum>): Accum {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0;
        message.sum = 0;
        message.min = 0;
        message.max = 0;
        if (value !== undefined)
            reflectionMergePartial<Accum>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Accum): Accum {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 count */ 1:
                    message.count = reader.int32();
                    break;
                case /* float sum */ 2:
                    message.sum = reader.float();
                    break;
                case /* float min */ 3:
                    message.min = reader.float();
                    break;
                case /* float max */ 4:
                    message.max = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Accum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 count = 1; */
        if (message.count !== 0)
            writer.tag(1, WireType.Varint).int32(message.count);
        /* float sum = 2; */
        if (message.sum !== 0)
            writer.tag(2, WireType.Bit32).float(message.sum);
        /* float min = 3; */
        if (message.min !== 0)
            writer.tag(3, WireType.Bit32).float(message.min);
        /* float max = 4; */
        if (message.max !== 0)
            writer.tag(4, WireType.Bit32).float(message.max);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Accum
 */
export const Accum = new Accum$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepStats$Type extends MessageType<StepStats> {
    constructor() {
        super("taskqueue.StepStats", [
            { no: 1, name: "step_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "step_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "waiting_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "pending_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "accepted_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "running_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "uploading_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "successful_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "failed_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "really_failed_tasks", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "success_run", kind: "message", T: () => Accum },
            { no: 13, name: "failed_run", kind: "message", T: () => Accum },
            { no: 14, name: "running_run", kind: "message", T: () => Accum },
            { no: 15, name: "download", kind: "message", T: () => Accum },
            { no: 16, name: "upload", kind: "message", T: () => Accum },
            { no: 17, name: "start_time", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 18, name: "end_time", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/ },
            { no: 19, name: "stats_eval_time", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StepStats>): StepStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stepId = 0;
        message.stepName = "";
        message.totalTasks = 0;
        message.waitingTasks = 0;
        message.pendingTasks = 0;
        message.acceptedTasks = 0;
        message.runningTasks = 0;
        message.uploadingTasks = 0;
        message.successfulTasks = 0;
        message.failedTasks = 0;
        message.reallyFailedTasks = 0;
        message.statsEvalTime = 0;
        if (value !== undefined)
            reflectionMergePartial<StepStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepStats): StepStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 step_id */ 1:
                    message.stepId = reader.int32();
                    break;
                case /* string step_name */ 2:
                    message.stepName = reader.string();
                    break;
                case /* int32 total_tasks */ 3:
                    message.totalTasks = reader.int32();
                    break;
                case /* int32 waiting_tasks */ 4:
                    message.waitingTasks = reader.int32();
                    break;
                case /* int32 pending_tasks */ 5:
                    message.pendingTasks = reader.int32();
                    break;
                case /* int32 accepted_tasks */ 6:
                    message.acceptedTasks = reader.int32();
                    break;
                case /* int32 running_tasks */ 7:
                    message.runningTasks = reader.int32();
                    break;
                case /* int32 uploading_tasks */ 8:
                    message.uploadingTasks = reader.int32();
                    break;
                case /* int32 successful_tasks */ 9:
                    message.successfulTasks = reader.int32();
                    break;
                case /* int32 failed_tasks */ 10:
                    message.failedTasks = reader.int32();
                    break;
                case /* int32 really_failed_tasks */ 11:
                    message.reallyFailedTasks = reader.int32();
                    break;
                case /* taskqueue.Accum success_run */ 12:
                    message.successRun = Accum.internalBinaryRead(reader, reader.uint32(), options, message.successRun);
                    break;
                case /* taskqueue.Accum failed_run */ 13:
                    message.failedRun = Accum.internalBinaryRead(reader, reader.uint32(), options, message.failedRun);
                    break;
                case /* taskqueue.Accum running_run */ 14:
                    message.runningRun = Accum.internalBinaryRead(reader, reader.uint32(), options, message.runningRun);
                    break;
                case /* taskqueue.Accum download */ 15:
                    message.download = Accum.internalBinaryRead(reader, reader.uint32(), options, message.download);
                    break;
                case /* taskqueue.Accum upload */ 16:
                    message.upload = Accum.internalBinaryRead(reader, reader.uint32(), options, message.upload);
                    break;
                case /* optional int64 start_time */ 17:
                    message.startTime = reader.int64().toString();
                    break;
                case /* optional int64 end_time */ 18:
                    message.endTime = reader.int64().toString();
                    break;
                case /* int32 stats_eval_time */ 19:
                    message.statsEvalTime = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 step_id = 1; */
        if (message.stepId !== 0)
            writer.tag(1, WireType.Varint).int32(message.stepId);
        /* string step_name = 2; */
        if (message.stepName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.stepName);
        /* int32 total_tasks = 3; */
        if (message.totalTasks !== 0)
            writer.tag(3, WireType.Varint).int32(message.totalTasks);
        /* int32 waiting_tasks = 4; */
        if (message.waitingTasks !== 0)
            writer.tag(4, WireType.Varint).int32(message.waitingTasks);
        /* int32 pending_tasks = 5; */
        if (message.pendingTasks !== 0)
            writer.tag(5, WireType.Varint).int32(message.pendingTasks);
        /* int32 accepted_tasks = 6; */
        if (message.acceptedTasks !== 0)
            writer.tag(6, WireType.Varint).int32(message.acceptedTasks);
        /* int32 running_tasks = 7; */
        if (message.runningTasks !== 0)
            writer.tag(7, WireType.Varint).int32(message.runningTasks);
        /* int32 uploading_tasks = 8; */
        if (message.uploadingTasks !== 0)
            writer.tag(8, WireType.Varint).int32(message.uploadingTasks);
        /* int32 successful_tasks = 9; */
        if (message.successfulTasks !== 0)
            writer.tag(9, WireType.Varint).int32(message.successfulTasks);
        /* int32 failed_tasks = 10; */
        if (message.failedTasks !== 0)
            writer.tag(10, WireType.Varint).int32(message.failedTasks);
        /* int32 really_failed_tasks = 11; */
        if (message.reallyFailedTasks !== 0)
            writer.tag(11, WireType.Varint).int32(message.reallyFailedTasks);
        /* taskqueue.Accum success_run = 12; */
        if (message.successRun)
            Accum.internalBinaryWrite(message.successRun, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* taskqueue.Accum failed_run = 13; */
        if (message.failedRun)
            Accum.internalBinaryWrite(message.failedRun, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* taskqueue.Accum running_run = 14; */
        if (message.runningRun)
            Accum.internalBinaryWrite(message.runningRun, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* taskqueue.Accum download = 15; */
        if (message.download)
            Accum.internalBinaryWrite(message.download, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* taskqueue.Accum upload = 16; */
        if (message.upload)
            Accum.internalBinaryWrite(message.upload, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 start_time = 17; */
        if (message.startTime !== undefined)
            writer.tag(17, WireType.Varint).int64(message.startTime);
        /* optional int64 end_time = 18; */
        if (message.endTime !== undefined)
            writer.tag(18, WireType.Varint).int64(message.endTime);
        /* int32 stats_eval_time = 19; */
        if (message.statsEvalTime !== 0)
            writer.tag(19, WireType.Varint).int32(message.statsEvalTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.StepStats
 */
export const StepStats = new StepStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StepStatsResponse$Type extends MessageType<StepStatsResponse> {
    constructor() {
        super("taskqueue.StepStatsResponse", [
            { no: 1, name: "stats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StepStats }
        ]);
    }
    create(value?: PartialMessage<StepStatsResponse>): StepStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stats = [];
        if (value !== undefined)
            reflectionMergePartial<StepStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StepStatsResponse): StepStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.StepStats stats */ 1:
                    message.stats.push(StepStats.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StepStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.StepStats stats = 1; */
        for (let i = 0; i < message.stats.length; i++)
            StepStats.internalBinaryWrite(message.stats[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.StepStatsResponse
 */
export const StepStatsResponse = new StepStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerStats$Type extends MessageType<WorkerStats> {
    constructor() {
        super("taskqueue.WorkerStats", [
            { no: 1, name: "cpu_usage_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "mem_usage_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "load_1min", kind: "scalar", jsonName: "load1min", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "iowait_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "disks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DiskUsage },
            { no: 6, name: "disk_io", kind: "message", T: () => DiskIOStats },
            { no: 7, name: "net_io", kind: "message", T: () => NetIOStats }
        ]);
    }
    create(value?: PartialMessage<WorkerStats>): WorkerStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cpuUsagePercent = 0;
        message.memUsagePercent = 0;
        message.load1Min = 0;
        message.iowaitPercent = 0;
        message.disks = [];
        if (value !== undefined)
            reflectionMergePartial<WorkerStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerStats): WorkerStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float cpu_usage_percent */ 1:
                    message.cpuUsagePercent = reader.float();
                    break;
                case /* float mem_usage_percent */ 2:
                    message.memUsagePercent = reader.float();
                    break;
                case /* float load_1min */ 3:
                    message.load1Min = reader.float();
                    break;
                case /* float iowait_percent */ 4:
                    message.iowaitPercent = reader.float();
                    break;
                case /* repeated taskqueue.DiskUsage disks */ 5:
                    message.disks.push(DiskUsage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* taskqueue.DiskIOStats disk_io */ 6:
                    message.diskIo = DiskIOStats.internalBinaryRead(reader, reader.uint32(), options, message.diskIo);
                    break;
                case /* taskqueue.NetIOStats net_io */ 7:
                    message.netIo = NetIOStats.internalBinaryRead(reader, reader.uint32(), options, message.netIo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float cpu_usage_percent = 1; */
        if (message.cpuUsagePercent !== 0)
            writer.tag(1, WireType.Bit32).float(message.cpuUsagePercent);
        /* float mem_usage_percent = 2; */
        if (message.memUsagePercent !== 0)
            writer.tag(2, WireType.Bit32).float(message.memUsagePercent);
        /* float load_1min = 3; */
        if (message.load1Min !== 0)
            writer.tag(3, WireType.Bit32).float(message.load1Min);
        /* float iowait_percent = 4; */
        if (message.iowaitPercent !== 0)
            writer.tag(4, WireType.Bit32).float(message.iowaitPercent);
        /* repeated taskqueue.DiskUsage disks = 5; */
        for (let i = 0; i < message.disks.length; i++)
            DiskUsage.internalBinaryWrite(message.disks[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* taskqueue.DiskIOStats disk_io = 6; */
        if (message.diskIo)
            DiskIOStats.internalBinaryWrite(message.diskIo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* taskqueue.NetIOStats net_io = 7; */
        if (message.netIo)
            NetIOStats.internalBinaryWrite(message.netIo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerStats
 */
export const WorkerStats = new WorkerStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiskUsage$Type extends MessageType<DiskUsage> {
    constructor() {
        super("taskqueue.DiskUsage", [
            { no: 1, name: "device_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "usage_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<DiskUsage>): DiskUsage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deviceName = "";
        message.usagePercent = 0;
        if (value !== undefined)
            reflectionMergePartial<DiskUsage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiskUsage): DiskUsage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string device_name */ 1:
                    message.deviceName = reader.string();
                    break;
                case /* float usage_percent */ 2:
                    message.usagePercent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiskUsage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string device_name = 1; */
        if (message.deviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deviceName);
        /* float usage_percent = 2; */
        if (message.usagePercent !== 0)
            writer.tag(2, WireType.Bit32).float(message.usagePercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.DiskUsage
 */
export const DiskUsage = new DiskUsage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiskIOStats$Type extends MessageType<DiskIOStats> {
    constructor() {
        super("taskqueue.DiskIOStats", [
            { no: 1, name: "read_bytes_total", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "write_bytes_total", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "read_bytes_rate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "write_bytes_rate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<DiskIOStats>): DiskIOStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.readBytesTotal = "0";
        message.writeBytesTotal = "0";
        message.readBytesRate = 0;
        message.writeBytesRate = 0;
        if (value !== undefined)
            reflectionMergePartial<DiskIOStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiskIOStats): DiskIOStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 read_bytes_total */ 1:
                    message.readBytesTotal = reader.int64().toString();
                    break;
                case /* int64 write_bytes_total */ 2:
                    message.writeBytesTotal = reader.int64().toString();
                    break;
                case /* float read_bytes_rate */ 3:
                    message.readBytesRate = reader.float();
                    break;
                case /* float write_bytes_rate */ 4:
                    message.writeBytesRate = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiskIOStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 read_bytes_total = 1; */
        if (message.readBytesTotal !== "0")
            writer.tag(1, WireType.Varint).int64(message.readBytesTotal);
        /* int64 write_bytes_total = 2; */
        if (message.writeBytesTotal !== "0")
            writer.tag(2, WireType.Varint).int64(message.writeBytesTotal);
        /* float read_bytes_rate = 3; */
        if (message.readBytesRate !== 0)
            writer.tag(3, WireType.Bit32).float(message.readBytesRate);
        /* float write_bytes_rate = 4; */
        if (message.writeBytesRate !== 0)
            writer.tag(4, WireType.Bit32).float(message.writeBytesRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.DiskIOStats
 */
export const DiskIOStats = new DiskIOStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetIOStats$Type extends MessageType<NetIOStats> {
    constructor() {
        super("taskqueue.NetIOStats", [
            { no: 1, name: "recv_bytes_total", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "sent_bytes_total", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "recv_bytes_rate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "sent_bytes_rate", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<NetIOStats>): NetIOStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recvBytesTotal = "0";
        message.sentBytesTotal = "0";
        message.recvBytesRate = 0;
        message.sentBytesRate = 0;
        if (value !== undefined)
            reflectionMergePartial<NetIOStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetIOStats): NetIOStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 recv_bytes_total */ 1:
                    message.recvBytesTotal = reader.int64().toString();
                    break;
                case /* int64 sent_bytes_total */ 2:
                    message.sentBytesTotal = reader.int64().toString();
                    break;
                case /* float recv_bytes_rate */ 3:
                    message.recvBytesRate = reader.float();
                    break;
                case /* float sent_bytes_rate */ 4:
                    message.sentBytesRate = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetIOStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 recv_bytes_total = 1; */
        if (message.recvBytesTotal !== "0")
            writer.tag(1, WireType.Varint).int64(message.recvBytesTotal);
        /* int64 sent_bytes_total = 2; */
        if (message.sentBytesTotal !== "0")
            writer.tag(2, WireType.Varint).int64(message.sentBytesTotal);
        /* float recv_bytes_rate = 3; */
        if (message.recvBytesRate !== 0)
            writer.tag(3, WireType.Bit32).float(message.recvBytesRate);
        /* float sent_bytes_rate = 4; */
        if (message.sentBytesRate !== 0)
            writer.tag(4, WireType.Bit32).float(message.sentBytesRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.NetIOStats
 */
export const NetIOStats = new NetIOStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkerStatsRequest$Type extends MessageType<GetWorkerStatsRequest> {
    constructor() {
        super("taskqueue.GetWorkerStatsRequest", [
            { no: 1, name: "worker_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetWorkerStatsRequest>): GetWorkerStatsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetWorkerStatsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkerStatsRequest): GetWorkerStatsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 worker_ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.workerIds.push(reader.int32());
                    else
                        message.workerIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWorkerStatsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 worker_ids = 1; */
        if (message.workerIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.workerIds.length; i++)
                writer.int32(message.workerIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.GetWorkerStatsRequest
 */
export const GetWorkerStatsRequest = new GetWorkerStatsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWorkerStatsResponse$Type extends MessageType<GetWorkerStatsResponse> {
    constructor() {
        super("taskqueue.GetWorkerStatsResponse", [
            { no: 1, name: "worker_stats", kind: "map", K: 5 /*ScalarType.INT32*/, V: { kind: "message", T: () => WorkerStats } }
        ]);
    }
    create(value?: PartialMessage<GetWorkerStatsResponse>): GetWorkerStatsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerStats = {};
        if (value !== undefined)
            reflectionMergePartial<GetWorkerStatsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWorkerStatsResponse): GetWorkerStatsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<int32, taskqueue.WorkerStats> worker_stats */ 1:
                    this.binaryReadMap1(message.workerStats, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetWorkerStatsResponse["workerStats"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetWorkerStatsResponse["workerStats"] | undefined, val: GetWorkerStatsResponse["workerStats"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int32();
                    break;
                case 2:
                    val = WorkerStats.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for taskqueue.GetWorkerStatsResponse.worker_stats");
            }
        }
        map[key ?? 0] = val ?? WorkerStats.create();
    }
    internalBinaryWrite(message: GetWorkerStatsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<int32, taskqueue.WorkerStats> worker_stats = 1; */
        for (let k of globalThis.Object.keys(message.workerStats)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int32(parseInt(k));
            writer.tag(2, WireType.LengthDelimited).fork();
            WorkerStats.internalBinaryWrite(message.workerStats[k as any], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.GetWorkerStatsResponse
 */
export const GetWorkerStatsResponse = new GetWorkerStatsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchListRequest$Type extends MessageType<FetchListRequest> {
    constructor() {
        super("taskqueue.FetchListRequest", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FetchListRequest>): FetchListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uri = "";
        if (value !== undefined)
            reflectionMergePartial<FetchListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchListRequest): FetchListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.FetchListRequest
 */
export const FetchListRequest = new FetchListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchListResponse$Type extends MessageType<FetchListResponse> {
    constructor() {
        super("taskqueue.FetchListResponse", [
            { no: 1, name: "files", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FetchListResponse>): FetchListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<FetchListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchListResponse): FetchListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string files */ 1:
                    message.files.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string files = 1; */
        for (let i = 0; i < message.files.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.files[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.FetchListResponse
 */
export const FetchListResponse = new FetchListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchInfoResponse$Type extends MessageType<FetchInfoResponse> {
    constructor() {
        super("taskqueue.FetchInfoResponse", [
            { no: 1, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filename", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "is_file", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_dir", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FetchInfoResponse>): FetchInfoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uri = "";
        message.filename = "";
        message.description = "";
        message.size = "0";
        message.isFile = false;
        message.isDir = false;
        if (value !== undefined)
            reflectionMergePartial<FetchInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchInfoResponse): FetchInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.uri = reader.string();
                    break;
                case /* string filename */ 2:
                    message.filename = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* int64 size */ 4:
                    message.size = reader.int64().toString();
                    break;
                case /* bool is_file */ 5:
                    message.isFile = reader.bool();
                    break;
                case /* bool is_dir */ 6:
                    message.isDir = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.uri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uri);
        /* string filename = 2; */
        if (message.filename !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.filename);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* int64 size = 4; */
        if (message.size !== "0")
            writer.tag(4, WireType.Varint).int64(message.size);
        /* bool is_file = 5; */
        if (message.isFile !== false)
            writer.tag(5, WireType.Varint).bool(message.isFile);
        /* bool is_dir = 6; */
        if (message.isDir !== false)
            writer.tag(6, WireType.Varint).bool(message.isDir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.FetchInfoResponse
 */
export const FetchInfoResponse = new FetchInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadTemplateRequest$Type extends MessageType<UploadTemplateRequest> {
    constructor() {
        super("taskqueue.UploadTemplateRequest", [
            { no: 1, name: "script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "force", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UploadTemplateRequest>): UploadTemplateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.script = new Uint8Array(0);
        message.force = false;
        if (value !== undefined)
            reflectionMergePartial<UploadTemplateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadTemplateRequest): UploadTemplateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes script */ 1:
                    message.script = reader.bytes();
                    break;
                case /* bool force */ 2:
                    message.force = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadTemplateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes script = 1; */
        if (message.script.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.script);
        /* bool force = 2; */
        if (message.force !== false)
            writer.tag(2, WireType.Varint).bool(message.force);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.UploadTemplateRequest
 */
export const UploadTemplateRequest = new UploadTemplateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadTemplateResponse$Type extends MessageType<UploadTemplateResponse> {
    constructor() {
        super("taskqueue.UploadTemplateResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "workflow_template_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "param_json", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UploadTemplateResponse>): UploadTemplateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<UploadTemplateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadTemplateResponse): UploadTemplateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* optional int32 workflow_template_id */ 3:
                    message.workflowTemplateId = reader.int32();
                    break;
                case /* optional string name */ 4:
                    message.name = reader.string();
                    break;
                case /* optional string version */ 5:
                    message.version = reader.string();
                    break;
                case /* optional string description */ 6:
                    message.description = reader.string();
                    break;
                case /* optional string param_json */ 7:
                    message.paramJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadTemplateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* optional int32 workflow_template_id = 3; */
        if (message.workflowTemplateId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.workflowTemplateId);
        /* optional string name = 4; */
        if (message.name !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* optional string version = 5; */
        if (message.version !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* optional string description = 6; */
        if (message.description !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.description);
        /* optional string param_json = 7; */
        if (message.paramJson !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.paramJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.UploadTemplateResponse
 */
export const UploadTemplateResponse = new UploadTemplateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RunTemplateRequest$Type extends MessageType<RunTemplateRequest> {
    constructor() {
        super("taskqueue.RunTemplateRequest", [
            { no: 1, name: "workflow_template_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "param_values_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RunTemplateRequest>): RunTemplateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflowTemplateId = 0;
        message.paramValuesJson = "";
        if (value !== undefined)
            reflectionMergePartial<RunTemplateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RunTemplateRequest): RunTemplateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 workflow_template_id */ 1:
                    message.workflowTemplateId = reader.int32();
                    break;
                case /* string param_values_json */ 2:
                    message.paramValuesJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RunTemplateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 workflow_template_id = 1; */
        if (message.workflowTemplateId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workflowTemplateId);
        /* string param_values_json = 2; */
        if (message.paramValuesJson !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.paramValuesJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RunTemplateRequest
 */
export const RunTemplateRequest = new RunTemplateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemplateFilter$Type extends MessageType<TemplateFilter> {
    constructor() {
        super("taskqueue.TemplateFilter", [
            { no: 1, name: "workflow_template_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TemplateFilter>): TemplateFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TemplateFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemplateFilter): TemplateFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 workflow_template_id */ 1:
                    message.workflowTemplateId = reader.int32();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string version */ 3:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemplateFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 workflow_template_id = 1; */
        if (message.workflowTemplateId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.workflowTemplateId);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string version = 3; */
        if (message.version !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TemplateFilter
 */
export const TemplateFilter = new TemplateFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Template$Type extends MessageType<Template> {
    constructor() {
        super("taskqueue.Template", [
            { no: 1, name: "workflow_template_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "param_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "uploaded_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "uploaded_by", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Template>): Template {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workflowTemplateId = 0;
        message.name = "";
        message.version = "";
        message.description = "";
        message.paramJson = "";
        message.uploadedAt = "";
        if (value !== undefined)
            reflectionMergePartial<Template>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Template): Template {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 workflow_template_id */ 1:
                    message.workflowTemplateId = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string version */ 3:
                    message.version = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* string param_json */ 5:
                    message.paramJson = reader.string();
                    break;
                case /* string uploaded_at */ 6:
                    message.uploadedAt = reader.string();
                    break;
                case /* optional int32 uploaded_by */ 7:
                    message.uploadedBy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Template, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 workflow_template_id = 1; */
        if (message.workflowTemplateId !== 0)
            writer.tag(1, WireType.Varint).int32(message.workflowTemplateId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string version = 3; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* string param_json = 5; */
        if (message.paramJson !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.paramJson);
        /* string uploaded_at = 6; */
        if (message.uploadedAt !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.uploadedAt);
        /* optional int32 uploaded_by = 7; */
        if (message.uploadedBy !== undefined)
            writer.tag(7, WireType.Varint).int32(message.uploadedBy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Template
 */
export const Template = new Template$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemplateList$Type extends MessageType<TemplateList> {
    constructor() {
        super("taskqueue.TemplateList", [
            { no: 1, name: "templates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Template }
        ]);
    }
    create(value?: PartialMessage<TemplateList>): TemplateList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.templates = [];
        if (value !== undefined)
            reflectionMergePartial<TemplateList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemplateList): TemplateList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Template templates */ 1:
                    message.templates.push(Template.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemplateList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Template templates = 1; */
        for (let i = 0; i < message.templates.length; i++)
            Template.internalBinaryWrite(message.templates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TemplateList
 */
export const TemplateList = new TemplateList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemplateRun$Type extends MessageType<TemplateRun> {
    constructor() {
        super("taskqueue.TemplateRun", [
            { no: 1, name: "template_run_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "workflow_template_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "template_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "template_version", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "workflow_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "run_by", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "workflow_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "param_values_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "run_by_username", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TemplateRun>): TemplateRun {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.templateRunId = 0;
        message.workflowTemplateId = 0;
        message.status = "";
        message.createdAt = "";
        message.paramValuesJson = "";
        if (value !== undefined)
            reflectionMergePartial<TemplateRun>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemplateRun): TemplateRun {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 template_run_id */ 1:
                    message.templateRunId = reader.int32();
                    break;
                case /* int32 workflow_template_id */ 2:
                    message.workflowTemplateId = reader.int32();
                    break;
                case /* optional string template_name */ 3:
                    message.templateName = reader.string();
                    break;
                case /* optional string template_version */ 4:
                    message.templateVersion = reader.string();
                    break;
                case /* optional string workflow_name */ 5:
                    message.workflowName = reader.string();
                    break;
                case /* optional int32 run_by */ 6:
                    message.runBy = reader.int32();
                    break;
                case /* string status */ 7:
                    message.status = reader.string();
                    break;
                case /* optional int32 workflow_id */ 8:
                    message.workflowId = reader.int32();
                    break;
                case /* string created_at */ 9:
                    message.createdAt = reader.string();
                    break;
                case /* string param_values_json */ 10:
                    message.paramValuesJson = reader.string();
                    break;
                case /* optional string error_message */ 11:
                    message.errorMessage = reader.string();
                    break;
                case /* optional string run_by_username */ 12:
                    message.runByUsername = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemplateRun, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 template_run_id = 1; */
        if (message.templateRunId !== 0)
            writer.tag(1, WireType.Varint).int32(message.templateRunId);
        /* int32 workflow_template_id = 2; */
        if (message.workflowTemplateId !== 0)
            writer.tag(2, WireType.Varint).int32(message.workflowTemplateId);
        /* optional string template_name = 3; */
        if (message.templateName !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.templateName);
        /* optional string template_version = 4; */
        if (message.templateVersion !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.templateVersion);
        /* optional string workflow_name = 5; */
        if (message.workflowName !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.workflowName);
        /* optional int32 run_by = 6; */
        if (message.runBy !== undefined)
            writer.tag(6, WireType.Varint).int32(message.runBy);
        /* string status = 7; */
        if (message.status !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.status);
        /* optional int32 workflow_id = 8; */
        if (message.workflowId !== undefined)
            writer.tag(8, WireType.Varint).int32(message.workflowId);
        /* string created_at = 9; */
        if (message.createdAt !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.createdAt);
        /* string param_values_json = 10; */
        if (message.paramValuesJson !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.paramValuesJson);
        /* optional string error_message = 11; */
        if (message.errorMessage !== undefined)
            writer.tag(11, WireType.LengthDelimited).string(message.errorMessage);
        /* optional string run_by_username = 12; */
        if (message.runByUsername !== undefined)
            writer.tag(12, WireType.LengthDelimited).string(message.runByUsername);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TemplateRun
 */
export const TemplateRun = new TemplateRun$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemplateRunList$Type extends MessageType<TemplateRunList> {
    constructor() {
        super("taskqueue.TemplateRunList", [
            { no: 1, name: "runs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TemplateRun }
        ]);
    }
    create(value?: PartialMessage<TemplateRunList>): TemplateRunList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runs = [];
        if (value !== undefined)
            reflectionMergePartial<TemplateRunList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemplateRunList): TemplateRunList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.TemplateRun runs */ 1:
                    message.runs.push(TemplateRun.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemplateRunList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.TemplateRun runs = 1; */
        for (let i = 0; i < message.runs.length; i++)
            TemplateRun.internalBinaryWrite(message.runs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TemplateRunList
 */
export const TemplateRunList = new TemplateRunList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemplateRunFilter$Type extends MessageType<TemplateRunFilter> {
    constructor() {
        super("taskqueue.TemplateRunFilter", [
            { no: 1, name: "workflow_template_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TemplateRunFilter>): TemplateRunFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TemplateRunFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemplateRunFilter): TemplateRunFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 workflow_template_id */ 1:
                    message.workflowTemplateId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemplateRunFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 workflow_template_id = 1; */
        if (message.workflowTemplateId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.workflowTemplateId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.TemplateRunFilter
 */
export const TemplateRunFilter = new TemplateRunFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTemplateRunRequest$Type extends MessageType<UpdateTemplateRunRequest> {
    constructor() {
        super("taskqueue.UpdateTemplateRunRequest", [
            { no: 1, name: "template_run_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "workflow_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "error_message", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTemplateRunRequest>): UpdateTemplateRunRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.templateRunId = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateTemplateRunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTemplateRunRequest): UpdateTemplateRunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 template_run_id */ 1:
                    message.templateRunId = reader.int32();
                    break;
                case /* optional int32 workflow_id */ 2:
                    message.workflowId = reader.int32();
                    break;
                case /* optional string error_message */ 3:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTemplateRunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 template_run_id = 1; */
        if (message.templateRunId !== 0)
            writer.tag(1, WireType.Varint).int32(message.templateRunId);
        /* optional int32 workflow_id = 2; */
        if (message.workflowId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.workflowId);
        /* optional string error_message = 3; */
        if (message.errorMessage !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.UpdateTemplateRunRequest
 */
export const UpdateTemplateRunRequest = new UpdateTemplateRunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkspaceRootRequest$Type extends MessageType<WorkspaceRootRequest> {
    constructor() {
        super("taskqueue.WorkspaceRootRequest", [
            { no: 1, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkspaceRootRequest>): WorkspaceRootRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.provider = "";
        message.region = "";
        if (value !== undefined)
            reflectionMergePartial<WorkspaceRootRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkspaceRootRequest): WorkspaceRootRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider */ 1:
                    message.provider = reader.string();
                    break;
                case /* string region */ 2:
                    message.region = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkspaceRootRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider = 1; */
        if (message.provider !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.provider);
        /* string region = 2; */
        if (message.region !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.region);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkspaceRootRequest
 */
export const WorkspaceRootRequest = new WorkspaceRootRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkspaceRootResponse$Type extends MessageType<WorkspaceRootResponse> {
    constructor() {
        super("taskqueue.WorkspaceRootResponse", [
            { no: 1, name: "root_uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkspaceRootResponse>): WorkspaceRootResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rootUri = "";
        if (value !== undefined)
            reflectionMergePartial<WorkspaceRootResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkspaceRootResponse): WorkspaceRootResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_uri */ 1:
                    message.rootUri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkspaceRootResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_uri = 1; */
        if (message.rootUri !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootUri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkspaceRootResponse
 */
export const WorkspaceRootResponse = new WorkspaceRootResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTemplateRunRequest$Type extends MessageType<DeleteTemplateRunRequest> {
    constructor() {
        super("taskqueue.DeleteTemplateRunRequest", [
            { no: 1, name: "template_run_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTemplateRunRequest>): DeleteTemplateRunRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.templateRunId = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteTemplateRunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTemplateRunRequest): DeleteTemplateRunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 template_run_id */ 1:
                    message.templateRunId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTemplateRunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 template_run_id = 1; */
        if (message.templateRunId !== 0)
            writer.tag(1, WireType.Varint).int32(message.templateRunId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.DeleteTemplateRunRequest
 */
export const DeleteTemplateRunRequest = new DeleteTemplateRunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceSpec$Type extends MessageType<ResourceSpec> {
    constructor() {
        super("taskqueue.ResourceSpec", [
            { no: 1, name: "worker_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cpu", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "mem", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "disk", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ResourceSpec>): ResourceSpec {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerId = "";
        message.cpu = 0;
        message.mem = 0;
        message.disk = 0;
        if (value !== undefined)
            reflectionMergePartial<ResourceSpec>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceSpec): ResourceSpec {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string worker_id */ 1:
                    message.workerId = reader.string();
                    break;
                case /* int32 cpu */ 2:
                    message.cpu = reader.int32();
                    break;
                case /* float mem */ 3:
                    message.mem = reader.float();
                    break;
                case /* float disk */ 4:
                    message.disk = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string worker_id = 1; */
        if (message.workerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.workerId);
        /* int32 cpu = 2; */
        if (message.cpu !== 0)
            writer.tag(2, WireType.Varint).int32(message.cpu);
        /* float mem = 3; */
        if (message.mem !== 0)
            writer.tag(3, WireType.Bit32).float(message.mem);
        /* float disk = 4; */
        if (message.disk !== 0)
            writer.tag(4, WireType.Bit32).float(message.disk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ResourceSpec
 */
export const ResourceSpec = new ResourceSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerEvent$Type extends MessageType<WorkerEvent> {
    constructor() {
        super("taskqueue.WorkerEvent", [
            { no: 1, name: "worker_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "worker_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "event_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "details_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerEvent>): WorkerEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.workerName = "";
        message.level = "";
        message.eventClass = "";
        message.message = "";
        message.detailsJson = "";
        if (value !== undefined)
            reflectionMergePartial<WorkerEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerEvent): WorkerEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* string worker_name */ 2:
                    message.workerName = reader.string();
                    break;
                case /* string level */ 3:
                    message.level = reader.string();
                    break;
                case /* string event_class */ 4:
                    message.eventClass = reader.string();
                    break;
                case /* string message */ 5:
                    message.message = reader.string();
                    break;
                case /* string details_json */ 6:
                    message.detailsJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 worker_id = 1; */
        if (message.workerId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* string worker_name = 2; */
        if (message.workerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.workerName);
        /* string level = 3; */
        if (message.level !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.level);
        /* string event_class = 4; */
        if (message.eventClass !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.eventClass);
        /* string message = 5; */
        if (message.message !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.message);
        /* string details_json = 6; */
        if (message.detailsJson !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.detailsJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerEvent
 */
export const WorkerEvent = new WorkerEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerEventFilter$Type extends MessageType<WorkerEventFilter> {
    constructor() {
        super("taskqueue.WorkerEventFilter", [
            { no: 1, name: "worker_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "level", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "limit", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerEventFilter>): WorkerEventFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorkerEventFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerEventFilter): WorkerEventFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 worker_id */ 1:
                    message.workerId = reader.int32();
                    break;
                case /* optional string level */ 2:
                    message.level = reader.string();
                    break;
                case /* optional string class */ 3:
                    message.class = reader.string();
                    break;
                case /* optional int32 limit */ 4:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerEventFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 worker_id = 1; */
        if (message.workerId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.workerId);
        /* optional string level = 2; */
        if (message.level !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.level);
        /* optional string class = 3; */
        if (message.class !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.class);
        /* optional int32 limit = 4; */
        if (message.limit !== undefined)
            writer.tag(4, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerEventFilter
 */
export const WorkerEventFilter = new WorkerEventFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerEventRecord$Type extends MessageType<WorkerEventRecord> {
    constructor() {
        super("taskqueue.WorkerEventRecord", [
            { no: 1, name: "event_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "worker_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "worker_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "event_class", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "details_json", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerEventRecord>): WorkerEventRecord {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventId = 0;
        message.createdAt = "";
        message.workerName = "";
        message.level = "";
        message.eventClass = "";
        message.message = "";
        message.detailsJson = "";
        if (value !== undefined)
            reflectionMergePartial<WorkerEventRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerEventRecord): WorkerEventRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 event_id */ 1:
                    message.eventId = reader.int32();
                    break;
                case /* string created_at */ 2:
                    message.createdAt = reader.string();
                    break;
                case /* optional int32 worker_id */ 3:
                    message.workerId = reader.int32();
                    break;
                case /* string worker_name */ 4:
                    message.workerName = reader.string();
                    break;
                case /* string level */ 5:
                    message.level = reader.string();
                    break;
                case /* string event_class */ 6:
                    message.eventClass = reader.string();
                    break;
                case /* string message */ 7:
                    message.message = reader.string();
                    break;
                case /* string details_json */ 8:
                    message.detailsJson = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerEventRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 event_id = 1; */
        if (message.eventId !== 0)
            writer.tag(1, WireType.Varint).int32(message.eventId);
        /* string created_at = 2; */
        if (message.createdAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.createdAt);
        /* optional int32 worker_id = 3; */
        if (message.workerId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.workerId);
        /* string worker_name = 4; */
        if (message.workerName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.workerName);
        /* string level = 5; */
        if (message.level !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.level);
        /* string event_class = 6; */
        if (message.eventClass !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.eventClass);
        /* string message = 7; */
        if (message.message !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.message);
        /* string details_json = 8; */
        if (message.detailsJson !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.detailsJson);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerEventRecord
 */
export const WorkerEventRecord = new WorkerEventRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerEventList$Type extends MessageType<WorkerEventList> {
    constructor() {
        super("taskqueue.WorkerEventList", [
            { no: 1, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WorkerEventRecord }
        ]);
    }
    create(value?: PartialMessage<WorkerEventList>): WorkerEventList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<WorkerEventList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerEventList): WorkerEventList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.WorkerEventRecord events */ 1:
                    message.events.push(WorkerEventRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerEventList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.WorkerEventRecord events = 1; */
        for (let i = 0; i < message.events.length; i++)
            WorkerEventRecord.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerEventList
 */
export const WorkerEventList = new WorkerEventList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerEventId$Type extends MessageType<WorkerEventId> {
    constructor() {
        super("taskqueue.WorkerEventId", [
            { no: 1, name: "event_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerEventId>): WorkerEventId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventId = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerEventId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerEventId): WorkerEventId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 event_id */ 1:
                    message.eventId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerEventId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 event_id = 1; */
        if (message.eventId !== 0)
            writer.tag(1, WireType.Varint).int32(message.eventId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerEventId
 */
export const WorkerEventId = new WorkerEventId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerEventPruneFilter$Type extends MessageType<WorkerEventPruneFilter> {
    constructor() {
        super("taskqueue.WorkerEventPruneFilter", [
            { no: 1, name: "before", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "level", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "class", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "worker_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "dry_run", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerEventPruneFilter>): WorkerEventPruneFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dryRun = false;
        if (value !== undefined)
            reflectionMergePartial<WorkerEventPruneFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerEventPruneFilter): WorkerEventPruneFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string before */ 1:
                    message.before = reader.string();
                    break;
                case /* optional string level */ 2:
                    message.level = reader.string();
                    break;
                case /* optional string class */ 3:
                    message.class = reader.string();
                    break;
                case /* optional int32 worker_id */ 4:
                    message.workerId = reader.int32();
                    break;
                case /* bool dry_run */ 5:
                    message.dryRun = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerEventPruneFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string before = 1; */
        if (message.before !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.before);
        /* optional string level = 2; */
        if (message.level !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.level);
        /* optional string class = 3; */
        if (message.class !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.class);
        /* optional int32 worker_id = 4; */
        if (message.workerId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.workerId);
        /* bool dry_run = 5; */
        if (message.dryRun !== false)
            writer.tag(5, WireType.Varint).bool(message.dryRun);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerEventPruneFilter
 */
export const WorkerEventPruneFilter = new WorkerEventPruneFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorkerEventPruneResult$Type extends MessageType<WorkerEventPruneResult> {
    constructor() {
        super("taskqueue.WorkerEventPruneResult", [
            { no: 1, name: "matched", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "deleted", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WorkerEventPruneResult>): WorkerEventPruneResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.matched = 0;
        message.deleted = 0;
        if (value !== undefined)
            reflectionMergePartial<WorkerEventPruneResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorkerEventPruneResult): WorkerEventPruneResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 matched */ 1:
                    message.matched = reader.int32();
                    break;
                case /* int32 deleted */ 2:
                    message.deleted = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorkerEventPruneResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 matched = 1; */
        if (message.matched !== 0)
            writer.tag(1, WireType.Varint).int32(message.matched);
        /* int32 deleted = 2; */
        if (message.deleted !== 0)
            writer.tag(2, WireType.Varint).int32(message.deleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.WorkerEventPruneResult
 */
export const WorkerEventPruneResult = new WorkerEventPruneResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Provider$Type extends MessageType<Provider> {
    constructor() {
        super("taskqueue.Provider", [
            { no: 1, name: "provider_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "config_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Provider>): Provider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerId = 0;
        message.providerName = "";
        message.configName = "";
        if (value !== undefined)
            reflectionMergePartial<Provider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Provider): Provider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 provider_id */ 1:
                    message.providerId = reader.int32();
                    break;
                case /* string provider_name */ 2:
                    message.providerName = reader.string();
                    break;
                case /* string config_name */ 3:
                    message.configName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Provider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 provider_id = 1; */
        if (message.providerId !== 0)
            writer.tag(1, WireType.Varint).int32(message.providerId);
        /* string provider_name = 2; */
        if (message.providerName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.providerName);
        /* string config_name = 3; */
        if (message.configName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.configName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Provider
 */
export const Provider = new Provider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProviderList$Type extends MessageType<ProviderList> {
    constructor() {
        super("taskqueue.ProviderList", [
            { no: 1, name: "providers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Provider }
        ]);
    }
    create(value?: PartialMessage<ProviderList>): ProviderList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providers = [];
        if (value !== undefined)
            reflectionMergePartial<ProviderList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProviderList): ProviderList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Provider providers */ 1:
                    message.providers.push(Provider.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProviderList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Provider providers = 1; */
        for (let i = 0; i < message.providers.length; i++)
            Provider.internalBinaryWrite(message.providers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.ProviderList
 */
export const ProviderList = new ProviderList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Region$Type extends MessageType<Region> {
    constructor() {
        super("taskqueue.Region", [
            { no: 1, name: "region_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "provider_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "region_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_default", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Region>): Region {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.regionId = 0;
        message.providerId = 0;
        message.regionName = "";
        message.isDefault = false;
        if (value !== undefined)
            reflectionMergePartial<Region>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Region): Region {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 region_id */ 1:
                    message.regionId = reader.int32();
                    break;
                case /* int32 provider_id */ 2:
                    message.providerId = reader.int32();
                    break;
                case /* string region_name */ 3:
                    message.regionName = reader.string();
                    break;
                case /* bool is_default */ 4:
                    message.isDefault = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Region, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 region_id = 1; */
        if (message.regionId !== 0)
            writer.tag(1, WireType.Varint).int32(message.regionId);
        /* int32 provider_id = 2; */
        if (message.providerId !== 0)
            writer.tag(2, WireType.Varint).int32(message.providerId);
        /* string region_name = 3; */
        if (message.regionName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.regionName);
        /* bool is_default = 4; */
        if (message.isDefault !== false)
            writer.tag(4, WireType.Varint).bool(message.isDefault);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.Region
 */
export const Region = new Region$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegionList$Type extends MessageType<RegionList> {
    constructor() {
        super("taskqueue.RegionList", [
            { no: 1, name: "regions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Region }
        ]);
    }
    create(value?: PartialMessage<RegionList>): RegionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.regions = [];
        if (value !== undefined)
            reflectionMergePartial<RegionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegionList): RegionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated taskqueue.Region regions */ 1:
                    message.regions.push(Region.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated taskqueue.Region regions = 1; */
        for (let i = 0; i < message.regions.length; i++)
            Region.internalBinaryWrite(message.regions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.RegionList
 */
export const RegionList = new RegionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlavorCreateRequest$Type extends MessageType<FlavorCreateRequest> {
    constructor() {
        super("taskqueue.FlavorCreateRequest", [
            { no: 1, name: "provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "config_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "flavor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "cpu", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "memory", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "disk", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "bandwidth", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "gpu", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "gpumem", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "has_gpu", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "has_quick_disks", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "region_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "costs", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 14, name: "evictions", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<FlavorCreateRequest>): FlavorCreateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerName = "";
        message.configName = "";
        message.flavorName = "";
        message.cpu = 0;
        message.memory = 0;
        message.disk = 0;
        message.regionNames = [];
        message.costs = [];
        message.evictions = [];
        if (value !== undefined)
            reflectionMergePartial<FlavorCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlavorCreateRequest): FlavorCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider_name */ 1:
                    message.providerName = reader.string();
                    break;
                case /* string config_name */ 2:
                    message.configName = reader.string();
                    break;
                case /* string flavor_name */ 3:
                    message.flavorName = reader.string();
                    break;
                case /* int32 cpu */ 4:
                    message.cpu = reader.int32();
                    break;
                case /* float memory */ 5:
                    message.memory = reader.float();
                    break;
                case /* float disk */ 6:
                    message.disk = reader.float();
                    break;
                case /* optional int32 bandwidth */ 7:
                    message.bandwidth = reader.int32();
                    break;
                case /* optional string gpu */ 8:
                    message.gpu = reader.string();
                    break;
                case /* optional int32 gpumem */ 9:
                    message.gpumem = reader.int32();
                    break;
                case /* optional bool has_gpu */ 10:
                    message.hasGpu = reader.bool();
                    break;
                case /* optional bool has_quick_disks */ 11:
                    message.hasQuickDisks = reader.bool();
                    break;
                case /* repeated string region_names */ 12:
                    message.regionNames.push(reader.string());
                    break;
                case /* repeated float costs */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.costs.push(reader.float());
                    else
                        message.costs.push(reader.float());
                    break;
                case /* repeated float evictions */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.evictions.push(reader.float());
                    else
                        message.evictions.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlavorCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider_name = 1; */
        if (message.providerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.providerName);
        /* string config_name = 2; */
        if (message.configName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.configName);
        /* string flavor_name = 3; */
        if (message.flavorName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.flavorName);
        /* int32 cpu = 4; */
        if (message.cpu !== 0)
            writer.tag(4, WireType.Varint).int32(message.cpu);
        /* float memory = 5; */
        if (message.memory !== 0)
            writer.tag(5, WireType.Bit32).float(message.memory);
        /* float disk = 6; */
        if (message.disk !== 0)
            writer.tag(6, WireType.Bit32).float(message.disk);
        /* optional int32 bandwidth = 7; */
        if (message.bandwidth !== undefined)
            writer.tag(7, WireType.Varint).int32(message.bandwidth);
        /* optional string gpu = 8; */
        if (message.gpu !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.gpu);
        /* optional int32 gpumem = 9; */
        if (message.gpumem !== undefined)
            writer.tag(9, WireType.Varint).int32(message.gpumem);
        /* optional bool has_gpu = 10; */
        if (message.hasGpu !== undefined)
            writer.tag(10, WireType.Varint).bool(message.hasGpu);
        /* optional bool has_quick_disks = 11; */
        if (message.hasQuickDisks !== undefined)
            writer.tag(11, WireType.Varint).bool(message.hasQuickDisks);
        /* repeated string region_names = 12; */
        for (let i = 0; i < message.regionNames.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.regionNames[i]);
        /* repeated float costs = 13; */
        if (message.costs.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.costs.length; i++)
                writer.float(message.costs[i]);
            writer.join();
        }
        /* repeated float evictions = 14; */
        if (message.evictions.length) {
            writer.tag(14, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.evictions.length; i++)
                writer.float(message.evictions[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.FlavorCreateRequest
 */
export const FlavorCreateRequest = new FlavorCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FlavorId$Type extends MessageType<FlavorId> {
    constructor() {
        super("taskqueue.FlavorId", [
            { no: 1, name: "flavor_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FlavorId>): FlavorId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flavorId = 0;
        if (value !== undefined)
            reflectionMergePartial<FlavorId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlavorId): FlavorId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 flavor_id */ 1:
                    message.flavorId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlavorId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 flavor_id = 1; */
        if (message.flavorId !== 0)
            writer.tag(1, WireType.Varint).int32(message.flavorId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message taskqueue.FlavorId
 */
export const FlavorId = new FlavorId$Type();
/**
 * @generated ServiceType for protobuf service taskqueue.TaskQueue
 */
export const TaskQueue = new ServiceType("taskqueue.TaskQueue", [
    { name: "SubmitTask", options: {}, I: TaskRequest, O: TaskResponse },
    { name: "RegisterWorker", options: {}, I: WorkerInfo, O: WorkerId },
    { name: "PingAndTakeNewTasks", options: {}, I: PingAndGetNewTasksRequest, O: TaskListAndOther },
    { name: "UpdateTaskStatus", options: {}, I: TaskStatusUpdate, O: Ack },
    { name: "SendTaskLogs", clientStreaming: true, options: {}, I: TaskLog, O: Ack },
    { name: "StreamTaskLogsOutput", serverStreaming: true, options: {}, I: TaskId, O: TaskLog },
    { name: "StreamTaskLogsErr", serverStreaming: true, options: {}, I: TaskId, O: TaskLog },
    { name: "GetLogsChunk", options: {}, I: GetLogsRequest, O: LogChunkList },
    { name: "ListTasks", options: {}, I: ListTasksRequest, O: TaskList },
    { name: "RetryTask", options: {}, I: RetryTaskRequest, O: TaskResponse },
    { name: "ListWorkers", options: {}, I: ListWorkersRequest, O: WorkersList },
    { name: "CreateWorker", options: {}, I: WorkerRequest, O: WorkerIds },
    { name: "UpdateWorkerStatus", options: {}, I: WorkerStatus, O: Ack },
    { name: "DeleteWorker", options: {}, I: WorkerDeletion, O: JobId },
    { name: "UpdateWorker", options: {}, I: WorkerUpdateRequest, O: Ack },
    { name: "GetWorkerStatuses", options: {}, I: WorkerStatusRequest, O: WorkerStatusResponse },
    { name: "ListJobs", options: {}, I: ListJobsRequest, O: JobsList },
    { name: "GetJobStatuses", options: {}, I: JobStatusRequest, O: JobStatusResponse },
    { name: "DeleteJob", options: {}, I: JobId, O: Ack },
    { name: "UpdateJob", options: {}, I: JobUpdate, O: Ack },
    { name: "ListFlavors", options: {}, I: ListFlavorsRequest, O: FlavorsList },
    { name: "ListProviders", options: {}, I: Empty, O: ProviderList },
    { name: "ListRegions", options: {}, I: Empty, O: RegionList },
    { name: "CreateFlavor", options: {}, I: FlavorCreateRequest, O: FlavorId },
    { name: "GetRcloneConfig", options: {}, I: Empty, O: RcloneRemotes },
    { name: "GetDockerCredentials", options: {}, I: Empty, O: DockerCredentials },
    { name: "Login", options: {}, I: LoginRequest, O: LoginResponse },
    { name: "Logout", options: {}, I: Token, O: Ack },
    { name: "CreateUser", options: {}, I: CreateUserRequest, O: UserId },
    { name: "ListUsers", options: {}, I: Empty, O: UsersList },
    { name: "DeleteUser", options: {}, I: UserId, O: Ack },
    { name: "UpdateUser", options: {}, I: User, O: Ack },
    { name: "ChangePassword", options: {}, I: ChangePasswordRequest, O: Ack },
    { name: "ListRecruiters", options: {}, I: RecruiterFilter, O: RecruiterList },
    { name: "CreateRecruiter", options: {}, I: Recruiter, O: Ack },
    { name: "UpdateRecruiter", options: {}, I: RecruiterUpdate, O: Ack },
    { name: "DeleteRecruiter", options: {}, I: RecruiterId, O: Ack },
    { name: "ListWorkflows", options: {}, I: WorkflowFilter, O: WorkflowList },
    { name: "CreateWorkflow", options: {}, I: WorkflowRequest, O: WorkflowId },
    { name: "DeleteWorkflow", options: {}, I: WorkflowId, O: Ack },
    { name: "ListSteps", options: {}, I: StepFilter, O: StepList },
    { name: "CreateStep", options: {}, I: StepRequest, O: StepId },
    { name: "DeleteStep", options: {}, I: StepId, O: Ack },
    { name: "GetStepStats", options: {}, I: StepStatsRequest, O: StepStatsResponse },
    { name: "GetWorkerStats", options: {}, I: GetWorkerStatsRequest, O: GetWorkerStatsResponse },
    { name: "FetchList", options: {}, I: FetchListRequest, O: FetchListResponse },
    { name: "FetchInfo", options: {}, I: FetchListRequest, O: FetchInfoResponse },
    { name: "UploadTemplate", options: {}, I: UploadTemplateRequest, O: UploadTemplateResponse },
    { name: "RunTemplate", options: {}, I: RunTemplateRequest, O: TemplateRun },
    { name: "ListTemplates", options: {}, I: TemplateFilter, O: TemplateList },
    { name: "ListTemplateRuns", options: {}, I: TemplateRunFilter, O: TemplateRunList },
    { name: "UpdateTemplateRun", options: {}, I: UpdateTemplateRunRequest, O: Ack },
    { name: "DeleteTemplateRun", options: {}, I: DeleteTemplateRunRequest, O: Ack },
    { name: "GetWorkspaceRoot", options: {}, I: WorkspaceRootRequest, O: WorkspaceRootResponse },
    { name: "RegisterSpecifications", options: {}, I: ResourceSpec, O: Ack },
    { name: "ReportWorkerEvent", options: {}, I: WorkerEvent, O: Ack },
    { name: "ListWorkerEvents", options: {}, I: WorkerEventFilter, O: WorkerEventList },
    { name: "DeleteWorkerEvent", options: {}, I: WorkerEventId, O: Ack },
    { name: "PruneWorkerEvents", options: {}, I: WorkerEventPruneFilter, O: WorkerEventPruneResult }
]);
